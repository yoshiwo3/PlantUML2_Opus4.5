
# 技術決定記録（Technical Decisions）

**最終更新**: 2025-12-06

---

## 概要

このファイルは、プロジェクトの重要な技術決定を索引形式で記録します。

---
## 技術決定一覧

### TD-001: AI駆動開発標準の採用

**日付**: 2025-11-30
**ステータス**: Accepted

**決定内容**:
3層ドキュメント構造（Memory Bank / Session Log / Evidence）とMCPサーバー統合を採用

**理由**:
- トレーサビリティの向上（Evidence完備率100%）
- 作業効率化（自動化スクリプトで作業時間75%削減）
- 品質保証（doc-reviewerスコア96/100達成）

**影響**:
- すべての作業でEvidence 3点セット作成が必須
- MCPサーバー（Serena, Context7等）のセットアップが必要

---

### TD-002: PlantUML Validator MCP採用

**日付**: 2025-11-30
**ステータス**: Accepted

**決定内容**:
PlantUML構文検証にMCPサーバーを使用し、すべてのPlantUMLコードを検証必須とする

**理由**:
- 構文エラーの早期発見
- 検証ループによる100%成功保証
- ドキュメント品質向上

**影響**:
- PlantUMLコード作成時は必ず検証を実行
- 検証失敗時は最大5回リトライ

---

### TD-003: Google Cloud Run採用（MCP Validator）

**日付**: 2025-11-08
**ステータス**: Accepted

**決定内容**:
PlantUML Validator MCPサーバーをGoogle Cloud Runでホスティング

**理由**:
- サーバーレスでスケーラブル
- 東京リージョン（asia-northeast1）で低レイテンシ
- コスト効率が良い

**影響**:
- GCPプロジェクト（plantuml-477523）の管理が必要
- Dockerコンテナでのデプロイ

---

### TD-004: Serena MCP採用

**日付**: 2025-11-30
**ステータス**: Accepted

**決定内容**:
コードベース理解とシンボル検索にSerena MCPを使用

**理由**:
- トークン効率化（シンボル検索でトークン消費1/20）
- プロジェクトメモリ永続化
- 構造化されたコード解析

**影響**:
- .serena/project.yml での設定が必要
- .serena/memories/ でのメモリ管理

---

### TD-005: プロジェクト選択状態のSupabase保存

**日付**: 2025-12-06
**ステータス**: Accepted

**決定内容**:
ユーザーが最後に選択したプロジェクトの状態をSupabaseに保存する（`users.last_selected_project_id`）

**理由**:
- UX向上：前回の作業を即座に再開可能
- アーキテクチャ一貫性：本プロジェクトはSupabase中心設計
- クロスデバイス対応：どのデバイスからでも同じ状態で再開

**代替案（不採用）**:
- ローカルストレージ/React State：リロード時消失、デバイス固有
- 実装コストは低いがUX劣化

**影響**:
- usersテーブルに`last_selected_project_id`カラム追加
- プロジェクト選択時にSupabase更新APIコール

---

### TD-006: MVPデータ保存設計（Storage Only）

**日付**: 2025-12-06
**ステータス**: Accepted

**決定内容**:
MVPはSupabase Storageのみで構成し、DBテーブルは作成しない（auth.usersのみ使用）

**Storage構造**:
```
/{user_id}/
  └── {project_name}/
      ├── {diagram_name}.puml
      ├── {diagram_name}.excalidraw.json
      └── {diagram_name}.preview.svg
```

**ファイル形式**: B案（.puml + コメント内Markdown）
```plantuml
/'
# 図表タイトル
説明文（Markdown形式）
'/

@startuml
...PlantUMLコード...
@enduml
```

**理由**:
- MVPはシンプルに：DBテーブル設計・RLS設定の複雑さを回避
- Storage Policyで十分なアクセス制御が可能
- 実際に必要になってから対応（YAGNI原則）

**機能ロードマップ**:
| Phase | 機能 | 実装方法 |
|-------|------|---------|
| **MVP** | 図表一覧、プロジェクト管理、CRUD | Storage API のみ |
| **v3** | ファイル名検索、全文検索、バージョン管理 | DB追加 + 取込み機能 |

**代替案（不採用）**:
- DB中心（コンテンツDB保存）：複雑すぎる
- DB + Storage（メタデータDB、ファイルStorage）：過剰設計
- MVPでUUID/マニフェスト：v3で取込み機能として対応すれば十分

**v3移行戦略**:
- 「ファイル取込み機能」をv3で実装
- 取込み時にUUID付与・DBインデックス作成
- 既存ファイルは取込み機能で移行

**アーキテクチャ: Repository Pattern**

v3移行を容易にするため、ストレージ層を抽象化する。

```
┌─────────────────────────────────────────────┐
│           Application Layer                  │
│  (図表CRUD、プロジェクト管理、一覧取得)        │
└─────────────────┬───────────────────────────┘
                  │ 依存（Interface経由）
                  ▼
┌─────────────────────────────────────────────┐
│      IDiagramRepository (Interface)          │
│  - list(projectName): Diagram[]              │
│  - get(projectName, diagramName): Diagram    │
│  - save(diagram): void                       │
│  - delete(projectName, diagramName): void    │
└─────────────────┬───────────────────────────┘
                  │ 実装
        ┌─────────┴─────────┐
        ▼                   ▼
┌───────────────┐   ┌─────────────────┐
│ MVP: Storage  │   │ v3: DB+Storage  │
│ Repository    │   │ Repository      │
│ (Storage API) │   │ (Supabase DB)   │
└───────────────┘   └─────────────────┘
```

**Repository Pattern採用理由**:
- MVP→v3移行時、Repository実装の差し替えのみでOK
- アプリケーション層のコード変更不要（依存性逆転）
- テスト時にMock Repositoryで置換可能
- SOLID原則（特にDIP: 依存性逆転の原則）に準拠

**影響**:
- 業務フロー図3.6, 3.7の一部を修正が必要（Storage構造変更）
- バージョン管理（UC 3-7, 3-8）はv3に延期
- MVPでIDiagramRepository interfaceを定義し、StorageRepositoryを実装

**追記（2025-12-06）: 自動保存機能の削除**

Storage Only構成の決定により、30秒間隔の自動保存機能を削除。

| 項目 | MVP | v3 |
|------|-----|-----|
| **手動保存** | ✅ Ctrl+S/保存ボタン | ✅ |
| **自動保存** | ❌ 未実装（上書きリスク） | DB導入後に検討 |
| **未保存警告** | ✅ ページ離脱時に警告 | ✅ |

**削除理由**:
- Storage Only構成では30秒ごとにファイル上書き
- バージョン履歴なし（DBなし）でデータ損失リスク
- ユーザーの意図しない上書きが発生する可能性

**修正したドキュメント**:
- 業務フロー図: 8箇所（概要図、保存フロー、テーブル等）
- ユースケース図: 2箇所（note、UC 3-5テーブル）

---

### TD-007: AI機能プロバイダー構成（LLM/Embedding分離）

**日付**: 2025-12-07
**ステータス**: Accepted

**決定内容**:
AI機能のプロバイダーをLLMとEmbeddingで分離する

| 機能カテゴリ | プロバイダー | 接続方式 |
|-------------|-------------|---------|
| **LLM（Chat/Completion）** | OpenRouter | 統一API経由 |
| **Embedding** | OpenAI | 直接接続 |

**理由**:
- OpenRouterにはEmbedding専用APIがない（公式推奨は直接接続）
- OpenAIのtext-embedding-3-smallは最もコスト効率が良い（$0.02/M tokens）
- 各プロバイダーの強みを活かした構成

**アーキテクチャ**:
```
┌─────────────────────────────────────────────────────────────┐
│                    PlantUML Studio                           │
│   ┌─────────────────────┐    ┌─────────────────────────┐    │
│   │   LLM機能           │    │   Embedding機能          │    │
│   │   (Chat/Completion) │    │   (RAG/Learning)        │    │
│   └──────────┬──────────┘    └────────────┬────────────┘    │
└──────────────┼────────────────────────────┼──────────────────┘
               │                            │
               ▼                            ▼
      ┌────────────────┐          ┌────────────────┐
      │   OpenRouter   │          │   OpenAI API   │
      │   (統一API)    │          │   (直接接続)    │
      └────────────────┘          └────────────────┘
```

**機能一覧**:

| カテゴリ | 機能ID | 機能名 | プロバイダー |
|---------|:------:|-------|-------------|
| LLM管理 | LM-01 | LLMモデルを登録する | OpenRouter |
| LLM管理 | LM-02 | LLMモデルを切り替える | OpenRouter |
| LLM管理 | LM-03 | LLMプロンプトを管理する | OpenRouter |
| LLM管理 | LM-04 | LLMパラメータを設定する | OpenRouter |
| LLM管理 | LM-05 | LLMワークフローを定義する | OpenRouter |
| LLM管理 | LM-06 | LLM使用量を監視する | OpenRouter |
| LLM管理 | LM-07 | LLMフォールバックを設定する | OpenRouter |
| Embedding | EM-01 | Embeddingモデルを設定する | OpenAI |
| Embedding | EM-02 | Embedding使用量を監視する | OpenAI |
| 学習コンテンツ | LC-01 | 学習コンテンツを登録する | OpenAI Embedding |
| 学習コンテンツ | LC-02 | 学習コンテンツを管理する | OpenAI Embedding |

**API キー管理**:
```bash
# LLM用（OpenRouter経由）
OPENROUTER_API_KEY=sk-or-v1-xxxxx

# Embedding用（OpenAI直接）
OPENAI_API_KEY=sk-xxxxx
```

**技術仕様**:

| 項目 | LLM (OpenRouter) | Embedding (OpenAI) |
|------|------------------|-------------------|
| エンドポイント | `api.openrouter.ai/api/v1/chat/completions` | `api.openai.com/v1/embeddings` |
| 認証 | Bearer Token | Bearer Token |
| フォールバック | `models`配列 + `route: "fallback"` | 指数バックオフリトライ |
| コスト最適化 | `:floor`バリアント、プロンプトキャッシング | Batch API（50%削減）、MRL次元削減 |

**Embedding技術選定**:
| 項目 | 選定 | 理由 |
|------|------|------|
| モデル | text-embedding-3-small | コスト効率最高、MTEB 62.3% |
| 次元数 | 1536 | デフォルト精度維持 |
| ベクトルDB | Supabase pgvector | Supabase統一アーキテクチャ |
| インデックス | HNSW | 高速検索 |
| チャンクサイズ | 512 tokens | 技術文書向け |
| 検索方式 | Hybrid Search | ベクトル + 全文検索 |

**代替案（不採用）**:
- OpenRouter経由Embedding：専用APIなし
- 単一プロバイダー統一：各プロバイダーの強みを活かせない

**影響**:
- 2つのAPIキー管理が必要
- 使用量ログを別テーブルで管理（`llm_usage_logs`, `embedding_usage_logs`）
- サービス層で`LLMService`と`EmbeddingService`を分離

**関連ドキュメント**:
- `docs/evidence/20251206_openrouter_research/openrouter_llm_control_specification.md`
- `docs/evidence/20251206_openrouter_research/llm_management_feature_design.md`

---

### TD-008: LLMワークフローのDAG構造採用（Phase 2）

**日付**: 2025-12-10
**ステータス**: Accepted

**決定内容**:
LLMワークフロー機能（UC 5-6）において、複数LLMステップの連携をDAG（有向非巡回グラフ）構造で実現する

| 項目 | 決定 | 説明 |
|------|------|------|
| **UI** | ビジュアルノードエディタ | React Flow等で実装、直感的なドラッグ&ドロップ操作 |
| **入出力マッピング** | Jinja2テンプレート + AI支援 | `{{ step1.output }}`、`{{ step1.output.errors[0].message }}`等 |
| **出力スキーマ** | オプション（JSON Schema形式） | 必須ではないが、定義すれば型安全性向上 |
| **条件分岐** | success/error/always + LLM判定 | LLMにカスタム条件を判定させることも可能 |

**データモデル**:
```
llm_workflows          - ワークフロー定義のメタデータ
llm_workflow_steps     - 各ステップの定義（モデル、プロンプト、パラメータ）
llm_workflow_edges     - ステップ間の接続（条件分岐含む）
llm_workflow_step_inputs - ステップへの入力マッピング定義
```

**入出力マッピング例**:
```jinja2
{{ step1.output }}
{{ step1.output.errors[0].message }}
{% if step1.output.hasError %}...{% endif %}
```

**想定ワークフロー**:
- 構文チェック→AI修正（基本パターン）
- Question-Startフロー（質問分析→回答生成）
- カスタムワークフロー（ユーザー定義）

**理由**:
- 複雑なLLM処理を視覚的に設計可能
- ステップ間のデータフローを明示的に定義
- 再利用可能なワークフローテンプレートを作成可能
- エラー発生時の分岐処理を柔軟に設定

**代替案（不採用）**:
- 線形パイプライン：分岐処理が困難
- コード定義のみ：非エンジニアが使いにくい
- シンプルなチェイン：複雑な条件分岐に対応困難

**影響**:
- 4つの新規テーブル作成（llm_workflows, llm_workflow_steps, llm_workflow_edges, llm_workflow_step_inputs）
- React Flow等のDAGエディタライブラリ導入
- 業務フロー図3.11.2で表現

---

### TD-009: Embeddingモデル切り替え時の再生成戦略（Phase 2）

**日付**: 2025-12-10
**ステータス**: Accepted

**決定内容**:
Embeddingモデルを切り替える際、既存コンテンツのEmbedding再生成をオプションとして提供する

| 項目 | 決定 |
|------|------|
| **再生成オプション** | 「既存コンテンツ再生成」または「新規コンテンツのみ」を選択可能 |
| **追加フィールド** | `embedding_settings.regeneration_status`, `regeneration_progress` |
| **バックグラウンド処理** | 再生成はジョブキューで非同期実行 |

**理由**:
- モデル切り替え時に全コンテンツ再生成は時間・コストがかかる
- ユーザーが状況に応じて選択できるようにする
- 進捗表示でユーザー体験を向上

**選択可能オプション**:
1. **既存コンテンツを再生成**: すべてのコンテンツを新モデルで再Embedding化
2. **新規コンテンツのみ適用**: 既存コンテンツはそのまま、新規登録分から新モデル適用

**コスト見積もり表示**:
- 再生成対象件数
- 推定トークン数
- 推定コスト（USD）

**影響**:
- embedding_settingsテーブルに`regeneration_status`, `regeneration_progress`カラム追加
- バックグラウンドジョブキュー実装
- 業務フロー図3.11.3で表現

**関連ドキュメント**:
- `docs/proposals/03_業務フロー図_20251201.md` - 3.11セクション
- `docs/evidence/20251210_2230_admin_flow_phase2/`

---

### TD-016: エクスプローラー方式UI + リサイズ可能スライダー採用

**日付**: 2025-12-27
**ステータス**: Accepted

**決定内容**:
ホーム画面のサイドバーを「エクスプローラー方式」（ツリービュー）に変更し、サイドバーとメインエリアの境界にリサイズ可能なスライダーを設ける。

**画面サイズ仕様**:
| 項目 | 値 | 備考 |
|------|-----|------|
| 基準解像度 | 1920×1080 | Full HD |
| 最小ウィンドウ幅 | 1024px | ノートPC対応 |
| サイドバー初期幅 | 280px | - |
| サイドバー最小幅 | 200px | ツリー表示可能最小 |
| サイドバー最大幅 | 400px | 画面の約1/5まで |
| リサイザー幅 | 4px | ドラッグハンドル |
| メインエリア最小幅 | 600px | エディタ使用可能最小 |

**リサイザー仕様**:
- hover時: カーソルが `col-resize` に変化
- ドラッグ: サイドバー幅がリアルタイムで変化
- ダブルクリック: デフォルト幅（280px）にリセット
- 状態保存: localStorage に幅を保存、次回起動時に復元

**サイドバー構成（エクスプローラー方式）**:
```
📂 プロジェクト
├─ 📁 認証システム設計
│  ├─ 📄 シーケンス図.puml
│  └─ 📄 クラス図.puml
├─ 📁 API設計
│  └─ 📄 ...
└─ ➕ 新規プロジェクト

📚 学習コンテンツ
├─ PlantUML入門
└─ シーケンス図

⚙️ 設定
🚪 ログアウト
```

**理由**:
1. **開発者ターゲット親和性**: VS Code/IDE ライクなUIで直感的
2. **階層構造の可視化**: プロジェクト > 図表の関係が一目瞭然
3. **クイックアクセス**: 3クリック→1クリックで図表に到達
4. **作業コンテキスト保持**: 編集中の図表の位置が常に見える
5. **カスタマイズ性**: ユーザーが好みの幅に調整可能

**却下した選択肢**:
- フラットメニュー方式（v1.5）: 画面切り替え型でコンテキストが失われやすい
- VS Code完全模倣（アクティビティバー付き）: 過剰、実装複雑

**影響**:
- 画面遷移図を v1.5 → v1.6 に更新
- ホーム画面ワイヤーフレームを再設計
- サイドバーコンポーネントの実装（ツリービュー + リサイザー）

**関連ドキュメント**:
- `docs/evidence/20251224_1955_ui_design_login/wireframes/`
- `docs/proposals/diagrams/09_screen_transition/`

---

### TD-017: エディタ画面GUIパネルの図表タイプ別動的切り替え

**日付**: 2025-12-28
**ステータス**: Accepted

**決定内容**:
エディタ画面の左パネル（GUIパネル）は、編集対象の図表タイプに応じて動的に切り替える。各図表タイプに最適化されたGUIを提供することで、コード記述なしでの図表作成を支援する。

**GUIパネル構成（図表タイプ別）**:

| 図表タイプ | GUIパネル内容 | ワークフロー |
|-----------|--------------|-------------|
| **シーケンス図** | アクター選択、メッセージタイプ（同期/非同期/戻り）、メッセージリスト | STEP 1→2→3 |
| **クラス図** | クラス追加、属性/メソッド編集、関係性（継承/実装/関連/依存）| クラス定義→関係設定 |
| **ユースケース図** | アクター追加、ユースケース追加、関係性（include/extend）| アクター→UC→関係 |
| **アクティビティ図** | アクション追加、分岐/マージ、スイムレーン設定 | フロー構築 |
| **コンポーネント図** | コンポーネント追加、インターフェース、依存関係 | 構造定義 |
| **ステート図** | 状態追加、遷移定義、開始/終了状態 | 状態遷移設定 |
| **Excalidraw** | 描画ツール（矩形、楕円、矢印、テキスト、手書き線）| 自由描画 |

**切り替えトリガー**:
1. 図表選択時（ヘッダーのDiagram Selector変更）
2. 新規図表作成時（タイプ選択に応じて）
3. ファイル拡張子判定（`.puml` → PlantUML系、`.excalidraw` → Excalidraw）

**実装方針**:
```typescript
// GUIパネルコンポーネントの動的ロード
const guiPanelComponents = {
  'sequence': SequenceDiagramGUI,
  'class': ClassDiagramGUI,
  'usecase': UseCaseDiagramGUI,
  'activity': ActivityDiagramGUI,
  'component': ComponentDiagramGUI,
  'state': StateDiagramGUI,
  'excalidraw': ExcalidrawToolbar,
};

// 図表タイプに応じてGUIパネルを切り替え
const GUIPanel = guiPanelComponents[diagramType] || GenericCodeEditor;
```

**ワイヤーフレーム対応**:
```
04_editor/
├── default.excalidraw           # シーケンス図GUI（代表例）
├── gui_class.excalidraw         # クラス図GUI（必要時作成）
├── gui_usecase.excalidraw       # ユースケース図GUI（必要時作成）
├── gui_activity.excalidraw      # アクティビティ図GUI（必要時作成）
└── gui_excalidraw.excalidraw    # Excalidraw描画ツール（必要時作成）
```

**理由**:
1. **ユーザビリティ向上**: 各図表タイプに最適化されたGUIで学習コスト低減
2. **コード不要の図表作成**: GUIからの操作でPlantUMLコードを自動生成
3. **一貫したUX**: 左パネル=GUI、中央=コード、右=プレビューの3パネル構成を維持
4. **段階的実装**: MVP時点ではシーケンス図GUIのみ、Phase 2以降で他タイプ追加可能

**却下した選択肢**:
- 全図表タイプで共通GUI: 汎用性が低く、各図表の特性を活かせない
- GUIパネルなし（コードオンリー）: PlantUML初心者には敷居が高い

**MVP対応範囲**:
- シーケンス図GUI: ✅ 必須（最も使用頻度が高い）
- その他: Phase 2以降で順次対応

**関連ドキュメント**:
- `docs/evidence/20251224_1955_ui_design_login/wireframes/04_editor/`
- TD-015（ワイヤーフレーム方針）
- TD-016（エクスプローラー方式UI）

---

### TD-018: エディタパネル間同期アーキテクチャ

**日付**: 2025-12-28
**ステータス**: Accepted

**決定内容**:
エディタ画面の3パネル（GUI / Code / Preview）間の同期は**双方向同期（Model C）**を採用する。GUIパネルとCodeパネルは相互に編集可能であり、変更は自動的に同期される。Codeパネル（PlantUMLテキスト）を**正のソース（Source of Truth）**とする。

**同期モデル**:

```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│  GUI Panel   │←───→│  Code Panel  │────→│Preview Panel │
│（ビジュアル） │     │ （テキスト） │     │（レンダリング）│
└──────────────┘     └──────────────┘     └──────────────┘
      ↑                     ↑                    │
   初心者向け          パワーユーザー向け        読取専用
   どちらからでも編集可能
```

**同期タイミング**:

| 方向 | 遅延 | 理由 |
|------|:----:|------|
| GUI → Code | 0ms（即時） | ユーザー操作を即座に反映 |
| Code → GUI | 300ms（デバウンス） | タイピング中の頻繁な更新を防止 |
| Code → Preview | 500ms（デバウンス） | レンダリングコスト考慮 |

**同期ルール**:

1. **GUI変更時**: 即座にPlantUMLコードを生成してCodeパネルに反映
2. **Code変更時**: 300ms待機後にパースし、有効であればGUIに反映
3. **無効な構文**: GUIは最後の有効状態を維持、Codeパネルにエラー表示
4. **競合解決**: アクティブに編集中のパネルを優先

**カーソル同期**:

| 操作 | 動作 |
|------|------|
| GUIでメッセージ選択 | Codeの該当行にカーソル移動、Previewでハイライト |
| Codeで行クリック | GUIのメッセージ一覧で該当行をハイライト |
| アクティベーションモーダル起動 | 現在のカーソル位置での状態を表示 |

**無効構文時の動作**:

```
Code編集: "User -> : broken" （ターゲット欠落）

┌─ Code Panel ────────────────────────┐
│  User -> : broken                   │
│  ~~~~~~~~^ Error: 参加者名が必要    │
└─────────────────────────────────────┘

┌─ GUI Panel ─────────────────────────┐
│  ⚠ 構文エラー: 最後の有効状態を表示 │
│  (通常通り操作可能)                 │
└─────────────────────────────────────┘
```

**パーサー要件（Code → GUI同期用）**:

| パース対象 | PlantUML構文 | GUIセクション |
|-----------|-------------|--------------|
| 参加者 | `actor`, `participant`, `boundary`, etc. | Section 1 |
| メッセージ | `->`, `->>`, `-->`, etc. | Section 2, 4 |
| フラグメント | `alt`, `opt`, `loop`, etc. | Section 3, 4 |
| アクティベーション | `activate`, `++`, `--` | Section 4, Modal |
| ノート・区切り | `note`, `==`, `...` | Section 5 |

**実装方針**:

```typescript
// GUI → Code（即時）
const onGuiChange = (change: GuiChange) => {
  const newCode = generatePlantUML(guiState);
  codePanel.setValue(newCode);
  // Previewは500msデバウンス
  debouncedRenderPreview(newCode);
};

// Code → GUI（デバウンス）
const onCodeChange = debounce((code: string) => {
  const parseResult = parsePlantUML(code);
  if (parseResult.valid) {
    guiPanel.updateState(parseResult.ast);
  } else {
    guiPanel.showWarning(parseResult.errors);
    // 最後の有効状態を維持
  }
}, 300);
```

**視覚的フィードバック**:

```
┌─ Code Panel ─────────────────────────────────────┐
│  5 │ User -> AuthService: login()     │[GUI §4]│ ← リンク表示
│  6 │ activate AuthService             │[GUI §6]│
└──────────────────────────────────────────────────┘

┌─ GUI Panel ─────────────────────────────────────┐
│ ▼ メッセージ一覧                                 │
│  1. User → AuthService              [L5] ← 行番号│
└─────────────────────────────────────────────────┘
```

**理由**:
1. **初心者と上級者の両立**: GUIで視覚的に編集、Codeで直接記述の両方をサポート
2. **PlantUMLの本質**: テキストベースフォーマットのため、Codeを正のソースとする
3. **柔軟性**: GUIで対応できない高度な構文もCodeで直接記述可能
4. **学習促進**: GUI操作でコードがどう変わるか見ることでPlantUML学習を支援

**却下した選択肢**:
- **一方向同期（GUI→Code）**: パワーユーザーがCode編集できない
- **一方向同期（Code→GUI）**: GUI編集の意味がなくなる
- **モード切替型**: モード切替の摩擦、シームレスさに欠ける

**関連ドキュメント**:
- TD-017（GUIパネルの図表タイプ別切り替え）
- TD-015（ワイヤーフレーム方針）
- `docs/evidence/20251224_1955_ui_design_login/wireframes/04_editor/`

---

### TD-019: エディタ画面3層操作UI構造

**日付**: 2025-12-28
**ステータス**: Accepted

**決定内容**:
エディタ画面のGUI操作を3層構造で設計する。GUIパネル（300px）の操作性制約を、モーダルによる拡張操作で補完する。

**3層構造**:

| 層 | コンポーネント | 用途 | サイズ |
|:--:|---------------|------|--------|
| **1** | GUIパネル | 簡易操作、クイックアクセス | 幅: 300px（モード1）/ 950px（モード2） |
| **2** | メッセージ管理モーダル | 全メッセージ俯瞰、D&D、フラグメント化 | 幅: 900px、高: 700px（最小）|
| **3** | フラグメント編集モーダル | フラグメント内の詳細編集 | 幅: 700px、高: 600px（最小）|

**レスポンシブ対応（TD-016との整合性）**:
- モーダルは画面幅の80%を上限とし、最小サイズを下回る場合は最小サイズを維持
- 1920×1080での表示: メッセージ管理モーダル 900×700px、フラグメント編集 700×600px
- 1366×768での表示: メッセージ管理モーダル 1093×614px（80%×80%）、フラグメント編集は最小サイズ維持

**モーダル遷移**:

```
GUIパネル（層1）
    │
    ├─→ [メッセージ管理を開く] → メッセージ管理モーダル（層2）
    │                               │
    │                               ├─→ [フラグメント編集] → フラグメント編集モーダル（層3）
    │                               │
    │                               └─→ [適用] → GUIパネルに戻る
    │
    └─→ [フラグメント挿入] → フラグメント編集モーダル（層3・直接起動）
```

**層2: メッセージ管理モーダルの機能**:
- 2カラムレイアウト（左: 350px固定、右: 残り幅）
- 左カラム: メッセージ作成GUI + フラグメント挿入ボタン
- 右カラム: 全メッセージのカード表示（D&D対応）
- 参加者管理セクション（モーダル上部）
- 全体Note（across）管理セクション
- 複数選択→フラグメント一括適用

**D&Dによるメッセージ順序変更**:
- メッセージ一覧のカードをD&Dで並べ替え可能
- 並べ替え完了時、即座にCodeパネルのメッセージ行順序が更新される（TD-018: 0ms同期）
- Preview更新は500msデバウンス後に実行
- GUIパネル（層1）のSection 2（メッセージ表示）でも同様のD&D順序変更が可能

**Code更新メカニズム（差分更新方式）**:
- D&D完了時、移動対象のメッセージ行のみを差分更新
- 他の行（ユーザー手動編集部分含む）は維持
- 更新手順: ①移動元行を抽出 → ②移動先位置に挿入 → ③元位置の行を削除
- AST（抽象構文木）レベルでの行位置追跡により正確な差分を実現

**層3: フラグメント編集モーダルの機能**:
- 条件ブロック毎のメッセージ作成GUI（GUIパネルと同一コンポーネント再利用）
- 各条件内のメッセージ一覧（D&D対応）
- 条件追加（else, else if）
- フラグメントNote編集
- **プレビューなし**（右側Previewパネルで確認）

**理由**:
1. **操作性向上**: 狭いGUIパネルでは複雑な操作が困難
2. **メッセージ数対応**: 20〜50件のメッセージを俯瞰して操作可能
3. **フラグメント編集の複雑性**: 260px幅でネスト構造を表現困難
4. **コンポーネント再利用**: 層1のメッセージ作成GUIを層2/層3で再利用

**却下した選択肢**:

| 選択肢 | 却下理由 |
|--------|---------|
| GUIパネル内スクロールのみ | 全体俯瞰困難、D&D範囲限定 |
| 中央パネルにカード表示 | Code編集との競合、実装複雑化 |
| 右パネル（Preview横）にGUI配置 | Preview視認性低下 |
| ボトムシート方式 | デスクトップ向けとして不適切 |
| フローティングパネル方式 | 配置管理が複雑、ドラッグ操作と競合 |

**関連ドキュメント**:
- TD-016（1920×1080基準解像度）
- TD-018（パネル間同期アーキテクチャ）
- TD-021（パネルモード切替機構）
- `docs/evidence/20251224_1955_ui_design_login/wireframes/04_editor/gui_panel_design_discussion.md`

---

### TD-020: PlantUML Note・補助要素のGUI対応

**日付**: 2025-12-28
**ステータス**: Accepted

**決定内容**:
PlantUMLのNote機能および関連補助要素を3層操作UI構造（TD-019）全体でサポートする。

**対応するNote種類**:

| 種類 | PlantUML構文 | 用途 |
|------|-------------|------|
| **参加者Note** | `note left/right of <参加者>` | 参加者の状態・役割説明 |
| **メッセージNote** | `note left/right` (メッセージ直後) | メッセージの補足説明 |
| **範囲Note** | `note over <参加者1>, <参加者2>` | 複数参加者間の状態説明 |
| **全体Note** | `note across` | シーケンス全体への注記 |
| **六角形Note** | `hnote over <参加者>` | 状態表現用六角形ノート |
| **四角形Note** | `rnote over <参加者>` | 状態表現用四角形ノート |
| **複数行Note** | `note ... end note` | 長文の説明 |

**対応する補助要素**:

| 要素 | PlantUML構文 | 用途 | GUI操作 |
|------|-------------|------|---------|
| **区切り線** | `== タイトル ==` | シーケンスの論理区切り | Section 5ボタン |
| **遅延** | `...` / `... 説明 ...` | 時間経過の表現 | Section 5ボタン |
| **スペース** | `|||` / `||45||` | 視覚的な余白 | Section 5ボタン |

**3層構造でのNote操作**:

| 層 | Note種類 | 操作方法 |
|:--:|---------|---------|
| **1** GUIパネル | 全種類 | Section 5 [Note追加] ボタン → ポップオーバー |
| **2** メッセージ管理 | メッセージNote | カード内 [Note+] ボタン、既存Noteのインライン編集 |
| **2** メッセージ管理 | 参加者Note | 参加者カード [Note N件] → 管理ポップオーバー |
| **2** メッセージ管理 | 全体Note | 専用セクション [+ Note追加] |
| **3** フラグメント編集 | フラグメントNote | 条件ブロック内 [Note編集] |
| **3** フラグメント編集 | メッセージNote | カード内 [Note+] ボタン |

**Note同期タイミング（TD-018準拠）**:

| 操作 | 同期タイミング | 備考 |
|------|:-------------:|------|
| Note追加 | 0ms（即時） | 追加ボタンクリック時 |
| Note編集 | 0ms（即時） | 編集確定時 |
| Note削除 | 0ms（即時） | 削除確認後 |
| Code→GUI Note検出 | 300ms | PlantUMLパーサーでnote構文を抽出 |

**パーサー実装方針**:

| 項目 | 方針 |
|------|------|
| **対応範囲** | ローカルJAR（node-plantuml）でレンダリング可能な**全構文** |
| **ライブラリ選定** | 自前実装（PlantUML公式ドキュメント準拠）|
| **GUI編集レベル** | 構文カテゴリ別に3段階（下表参照）|
| **エラーハンドリング** | パース失敗時はGUI最終有効状態を維持、Codeにエラー表示 |
| **パフォーマンス要件** | 300ms以内にパース完了（1000行以下のPlantUMLコード）|
| **テスト方針** | 複数レンダラーでの互換性テスト必須（※下記注釈参照）|

> **テスト用途の例外**: PlantUML Server APIは本番環境では使用禁止（CLAUDE.md技術仕様）だが、**テスト環境でのレンダリング互換性検証**に限り使用可。検証対象: PlantUML Server、VS Code PlantUML拡張、IntelliJ PlantUML Plugin。

**重要原則**:
- ローカルJARでレンダリング可能な構文は**全て認識**する
- 「GUI未対応」という概念は使用しない
- 構文検証はローカルJARに委任、パーサーは情報抽出に専念

**GUI編集レベル定義**:

| レベル | 対象構文 | GUI操作 | UI実装 | 将来計画 |
|:------:|---------|---------|--------|---------|
| **1** | message, participant, note, fragment, 補助要素 | 完全GUI編集 | フォーム入力、D&D並べ替え、モーダル編集 | - |
| **2** | skinparam, title, header, footer, autonumber | ポップオーバー編集 | 要素クリック→ポップオーバー表示→テキスト/設定値入力→確定で反映 | 完全GUI化検討 |
| **3** | !include, !define, !ifdef, box, newpage | 読み取り専用表示 | 折りたたみ表示（デフォルト）→展開でコード断片表示→「Codeで編集」リンク | 完全GUI化検討 |

**レベル別UI詳細**:

| レベル | 操作フロー | 同期タイミング |
|:------:|-----------|:-------------:|
| **1** | フォーム入力/D&D → 即時Code反映 | 0ms |
| **2** | 要素クリック → ポップオーバー → 入力 → 確定ボタン → Code反映 | 確定時0ms |
| **3** | 折りたたみ展開 → コード断片確認（読み取り専用）→ Codeパネルへ移動して編集 | N/A（表示のみ）|

**マイクロモジュール化アーキテクチャ（TD-022参照）**:
- GUIパネル全体をマイクロモジュール構成で実装
- 各構文カテゴリを独立モジュールとして実装
- 将来のレベル2→1、レベル3→1へのアップグレード時にモジュール差し替えで対応
- APIファースト設計により、モジュール間の疎結合を維持

**理由**:
1. **PlantUML本来の機能**: Note/区切り/遅延はシーケンス図の重要な説明要素
2. **非コーダー対応**: GUI操作でNote追加・編集を可能に
3. **一貫性**: メッセージ操作と同様のUI/UXでNote操作を提供
4. **TD-018準拠**: Note操作も即時同期でCodeに反映
5. **将来拡張性**: マイクロモジュール化により、レベル2〜3の完全GUI化に柔軟対応

**却下した選択肢**:

| 選択肢 | 却下理由 |
|--------|---------|
| 外部PlantUMLパーサーライブラリ使用 | 依存追加、カスタマイズ困難 |
| Note機能を層2モーダルのみに限定 | 簡易操作ができず、UX低下 |
| 補助要素（区切り/遅延）をCode編集のみ対応 | 非コーダーに不親切 |
| GUI未対応構文の存在を許容 | ローカルJARでレンダリング可能な構文は全て認識すべき |
| モノリシックなGUIパネル実装 | 将来のレベルアップグレード時に大規模改修が必要 |

**関連ドキュメント**:
- TD-018（パネル間同期アーキテクチャ）
- TD-019（3層操作UI構造）
- TD-022（APIファースト・マイクロモジュール化方針）
- `docs/evidence/20251224_1955_ui_design_login/wireframes/04_editor/gui_panel_design_discussion.md`

---

### TD-021: エディタ画面パネルモード切替機構

**日付**: 2025-12-28
**ステータス**: Accepted

**決定内容**:
エディタ画面のGUIパネル幅制約（300px）を補完するため、3つのパネルモードを切り替え可能にする。

**3モード定義**:

| モード | 名称 | 対象ユーザー | レイアウト |
|:------:|------|-------------|-----------|
| **1** | GUI+Code | 全ユーザー（デフォルト）| GUI 300px + Code 650px + Preview 962px |
| **2** | GUIのみ | 非コーダー、学習者 | GUI 950px + Preview 962px |
| **3** | Codeのみ | 上級者、パワーユーザー | Code 950px + Preview 962px |

**レイアウト図**:

```
モード1: GUI+Code（デフォルト）
┌────────┬────────────┬────────────┐
│ GUI    │ Code       │ Preview    │
│ 300px  │ 650px      │ 962px      │
└────────┴────────────┴────────────┘

モード2: GUI のみ
┌───────────────────┬────────────┐
│ GUI               │ Preview    │
│ 950px             │ 962px      │
└───────────────────┴────────────┘

モード3: Code のみ
┌────────────────────┬───────────┐
│ Code               │ Preview   │
│ 950px              │ 962px     │
└────────────────────┴───────────┘
```

**トグルUI配置**:
- ヘッダー右側にトグルボタングループを配置
- アイコン: [GUI+Code] [GUI] [Code]
- 現在モードをハイライト表示

**キーボードショートカット**:
- `Ctrl+1`: モード1（GUI+Code）
- `Ctrl+2`: モード2（GUIのみ）
- `Ctrl+3`: モード3（Codeのみ）

**状態永続化**:
- ユーザー設定としてSupabaseに保存（`users.preferred_editor_mode`）
- 次回ログイン時に前回のモードを復元

**モード切替時の同期動作（TD-018連携）**:

| 切替パターン | 動作 |
|-------------|------|
| モード1→モード2 | Codeパネル非表示、GUIは即座に拡大 |
| モード1→モード3 | GUIパネル非表示、Codeは即座に拡大 |
| モード2→モード1 | GUIを縮小、Code表示（Code→GUI 300ms同期発火）|
| モード3→モード1 | Codeを縮小、GUI表示（Code→GUI 300ms同期発火）|

**理由**:
1. **操作性向上**: GUIパネルを950pxに拡大することで詳細操作が容易に
2. **ユーザー多様性対応**: 非コーダーはGUIのみ、上級者はCodeのみで効率的作業
3. **学習支援**: モード1でGUI操作→Code変化を観察しPlantUML学習
4. **TD-016整合性**: 1920×1080基準で各モードのピクセル値を最適化

**却下した選択肢**:

| 選択肢 | 却下理由 |
|--------|---------|
| 4モード以上（Preview非表示等） | 複雑化、Previewは常に必要 |
| モード2でCode完全削除 | 同期のためCode（非表示でも）は内部維持必要 |
| リサイザーのみでモード切替 | ワンクリック切替の利便性喪失 |
| モード設定をlocalStorageのみ | デバイス間同期不可、TD-005方針に反する |

**関連ドキュメント**:
- TD-005（プロジェクト選択状態のSupabase保存）
- TD-016（1920×1080基準解像度）
- TD-018（パネル間同期アーキテクチャ）
- TD-019（3層操作UI構造）

---

### TD-022: APIファースト・マイクロモジュール化方針

**日付**: 2025-12-28
**ステータス**: Accepted
**スコープ**: プロジェクト全体

**決定内容**:
PlantUML Studioの開発において、**APIファースト**かつ**マイクロモジュール化**を基本方針として採用する。特にGUIパネルは機能差替可能な設計とし、将来のGUI編集レベル向上（TD-020参照）に備える。

**APIファースト原則**:

| 原則 | 説明 |
|------|------|
| **API定義先行** | 実装前にインターフェースを定義 |
| **疎結合** | モジュール間はAPI経由でのみ通信 |
| **契約駆動** | TypeScript型定義による契約の明示化 |
| **テスト容易性** | モジュール単位でのユニットテスト可能 |

**マイクロモジュールアーキテクチャ**:

```
┌─────────────────────────────────────────────────────────────────────┐
│                    GUIパネルコンテナ                                │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │                   Module Registry API                         │  │
│  │   register() / replace() / get() / list()                    │  │
│  └───────────────────────────────────────────────────────────────┘  │
│         │           │           │           │           │          │
│         ▼           ▼           ▼           ▼           ▼          │
│  ┌───────────┐┌───────────┐┌───────────┐┌───────────┐┌───────────┐ │
│  │Participant││ Message   ││ Fragment  ││   Note    ││ Skinparam │ │
│  │  Module   ││  Module   ││  Module   ││  Module   ││  Module   │ │
│  │  (Lv.1)   ││  (Lv.1)   ││  (Lv.1)   ││  (Lv.1)   ││  (Lv.2)   │ │
│  └───────────┘└───────────┘└───────────┘└───────────┘└───────────┘ │
│                                                                     │
│  ← 将来: Lv.2/3モジュールをLv.1版に差し替え可能                     │
└─────────────────────────────────────────────────────────────────────┘
```

**基本型定義**:

```typescript
// 全パース要素の基底型
interface ParsedElement {
  readonly id: string;              // 一意識別子（UUID）
  readonly type: string;            // 要素種別（'participant', 'message', 'note'等）
  readonly sourceRange: {           // 元Codeでの位置情報
    startLine: number;
    endLine: number;
    startColumn: number;
    endColumn: number;
  };
  readonly rawText: string;         // 元のPlantUMLテキスト
}

// 具象型の例
interface ParticipantElement extends ParsedElement {
  type: 'participant';
  name: string;
  alias?: string;
  stereotype?: string;
}

interface MessageElement extends ParsedElement {
  type: 'message';
  from: string;
  to: string;
  label: string;
  arrowType: 'sync' | 'async' | 'return';
}
```

**モジュールインターフェース（共通API）**:

```typescript
interface GUIModule<T extends ParsedElement> {
  // モジュール識別
  readonly id: string;           // 例: 'participant', 'message', 'skinparam'
  readonly version: string;      // セマンティックバージョニング: 'major.minor.patch'
  readonly guiLevel: 1 | 2 | 3;  // GUI編集レベル

  // パース機能（Code → 構造化データ）
  parse(code: string): T[];

  // コード生成機能（構造化データ → Code）
  generate(elements: T[]): string;

  // GUI描画機能
  render(elements: T[], container: HTMLElement): void;

  // イベントハンドラ（オプション、レベルにより実装）
  onEdit?(element: T, newValue: Partial<T>): void;
  onAdd?(element: T): void;
  onDelete?(elementId: string): void;
  onReorder?(elementIds: string[]): void;
}
```

**バージョニング戦略**:

| バージョン変更 | 条件 | 例 |
|:-------------:|------|-----|
| **major** | 破壊的変更（API非互換）| 1.0.0 → 2.0.0 |
| **minor** | 機能追加（後方互換）| 1.0.0 → 1.1.0 |
| **patch** | バグ修正 | 1.0.0 → 1.0.1 |

- モジュール差し替え時、majorバージョンが異なる場合は互換性チェック必須
- Module Registryは `replace()` 時にバージョン互換性を検証

**エラーハンドリング**:

| エラー種別 | 発生箇所 | 処理 |
|-----------|---------|------|
| パースエラー | `parse()` | 空配列を返却、エラーログ出力、GUIは最終有効状態を維持 |
| 生成エラー | `generate()` | 元のrawTextを返却、エラーログ出力 |
| 描画エラー | `render()` | エラープレースホルダーを表示、コンソールにスタックトレース |
| 登録エラー | `register()`/`replace()` | 例外をスロー、呼び出し元で処理 |

```typescript
// エラーハンドリング例
try {
  const elements = module.parse(code);
} catch (error) {
  console.error(`[${module.id}] Parse error:`, error);
  return lastValidElements; // フォールバック
}
```

**モジュール差し替えシナリオ（将来拡張）**:

| フェーズ | モジュール | バージョン | GUIレベル | 操作 |
|:-------:|-----------|:----------:|:---------:|------|
| MVP | SkinparamModule | v1.0 | 2 | インライン編集 |
| 将来 | SkinparamModule | v2.0 | 1 | ビジュアルエディタ（色選択、フォント選択） |

```typescript
// 差し替え方法（将来）
import { SkinparamModuleV2 } from '@/modules/skinparam/v2';
moduleRegistry.replace('skinparam', SkinparamModuleV2);
// 再レンダリングで新UIが自動的に表示される
```

**適用範囲**:

| コンポーネント | マイクロモジュール化 | 実装方針 | 差し替え可能性 |
|---------------|:------------------:|---------|---------------|
| GUIパネル | ✅ | 各構文カテゴリを独立モジュール化 | GUI編集レベル1/2/3のモジュール差し替え |
| パーサー | ✅ | 構文別パーサーモジュール | 新構文対応時にモジュール追加 |
| Codeエディタ | ❌ | Monaco Editor使用 | 外部ライブラリのため対象外 |
| Previewレンダラ | ❌ | node-plantuml使用 | 外部ライブラリのため対象外 |
| 認証 | ✅ | AuthProviderインターフェース | Supabase Auth → 将来別プロバイダーに差し替え可能 |
| ストレージ | ✅ | Repository Pattern（TD-006）| Storage Repository → 将来S3/GCS等に差し替え可能 |

**認証モジュール詳細**:
```typescript
interface AuthProvider {
  signIn(credentials: Credentials): Promise<User>;
  signOut(): Promise<void>;
  getSession(): Promise<Session | null>;
  onAuthStateChange(callback: (user: User | null) => void): Unsubscribe;
}

// MVP: Supabase Auth実装
class SupabaseAuthProvider implements AuthProvider { ... }

// 将来: 別プロバイダー実装
class Auth0Provider implements AuthProvider { ... }
```

**ストレージモジュール詳細**:
```typescript
// TD-006で定義済みのRepository Pattern
interface IDiagramRepository {
  list(projectName: string): Promise<Diagram[]>;
  get(projectName: string, diagramName: string): Promise<Diagram>;
  save(diagram: Diagram): Promise<void>;
  delete(projectName: string, diagramName: string): Promise<void>;
}

// MVP: Supabase Storage実装
class StorageRepository implements IDiagramRepository { ... }

// 将来: S3実装
class S3Repository implements IDiagramRepository { ... }
```

**理由**:
1. **将来拡張性**: レベル2〜3のGUI完全化に備えた柔軟な設計
2. **テスト容易性**: モジュール単位での独立テストが可能
3. **開発効率**: モジュール単位での並行開発が可能
4. **保守性**: 機能変更時の影響範囲を限定
5. **技術負債回避**: モノリシック実装による将来の大規模改修を防止

**却下した選択肢**:

| 選択肢 | 却下理由 |
|--------|---------|
| モノリシックなGUIパネル実装 | 将来のレベルアップグレード時に大規模改修必要 |
| 外部プラグインシステム | MVPには過剰設計、内部モジュールで十分 |
| マイクロサービス化 | フロントエンドのみのプロジェクトには不適切 |
| 動的モジュールローディング | バンドルサイズ管理が複雑化 |

**関連ドキュメント**:
- TD-006（MVPデータ保存設計 - Repository Pattern）
- TD-019（3層操作UI構造）
- TD-020（PlantUML Note・補助要素のGUI対応）
- `docs/evidence/20251224_1955_ui_design_login/wireframes/04_editor/gui_panel_design_discussion.md`

---

### TD-023: エディタ画面基本レイアウト

**日付**: 2025-12-28
**ステータス**: Accepted

**決定内容**:
エディタ画面の基本レイアウトを以下の通り定義する。この決定は、TD-016（ホーム画面サイドバー）とは独立した、エディタ画面固有のレイアウト定義である。

**3パネル構成（1920×1080基準）**:

| パネル | 幅 | 役割 | 備考 |
|--------|------|------|------|
| **GUIパネル** | 300px | 図表操作GUI（5セクション構成）| モード2では950pxに拡張 |
| **Codeパネル** | 650px | Monaco Editorによるコード編集 | モード3では950pxに拡張 |
| **Previewパネル** | 962px | PlantUML SVG表示 | 常時表示 |

**計算根拠**:
- 総幅: 1920px - 8px（パディング等）= 1912px
- GUIパネル: 300px（TD-019で定義）
- Codeパネル: 650px（Monaco Editor最小推奨幅）
- Previewパネル: 1912 - 300 - 650 = 962px

**AIチャットパネル（ボトム）**:

| 項目 | 仕様 | 備考 |
|------|------|------|
| 配置 | 3パネルの下部、全幅 | チャットUIの標準配置 |
| 高さ | 可変（最小120px、最大40%）| ユーザー調整可能 |
| 表示状態 | 常時表示 | 将来: 折りたたみ可能検討 |

**ヘッダー構成**:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ [Logo] PlantUML Studio │ ファイル名.puml │ [保存] [エクスポート] ... │ [■■□] │
└─────────────────────────────────────────────────────────────────────────────┘
                                                                      ↑
                                                            パネルモード切替トグル
                                                            [GUI+Code][GUI][Code]
```

| 要素 | 位置 | 機能 |
|------|------|------|
| ロゴ | 左端 | PlantUML Studio ブランド表示 |
| ファイル名 | 中央左 | 編集中の図表名表示（未保存マーカー付き）|
| アクションボタン | 中央右 | 保存、エクスポート、その他操作 |
| モード切替 | 右端 | 3モード切替トグル（TD-021）|

**レスポンシブブレークポイント**:

| ブレークポイント | レイアウト | パネル幅 | 備考 |
|-----------------|-----------|---------|------|
| ≥1920px | 3パネル（モード1/2/3選択可）| 300+650+962 | フルスペック |
| 1440-1919px | 3パネル（幅調整）| 250+500+690 | パネル幅を比例縮小 |
| 1280-1439px | 2パネル（Code+Preview）| 0+600+680 | GUIパネル非表示、モード3相当 |
| <1280px | 1パネル（タブ切替）| 全幅 | タブでGUI/Code/Preview切替 |

**モード別レイアウト（TD-021参照）**:

| モード | GUIパネル | Codeパネル | Previewパネル | 対象ユーザー |
|:------:|:---------:|:----------:|:-------------:|-------------|
| **1** GUI+Code | 300px | 650px | 962px | 標準（デフォルト）|
| **2** GUI only | 950px | 非表示（内部維持）| 962px | 非コーダー向け |
| **3** Code only | 非表示 | 950px | 962px | 上級者向け |

**パネル間境界**:

| 境界 | リサイズ可能 | 最小幅 | 備考 |
|------|:------------:|:------:|------|
| GUI↔Code | ❌ | - | 固定（MVPでは非対応）|
| Code↔Preview | ❌ | - | 固定（MVPでは非対応）|

> **将来検討**: パネル幅のリサイズ機能はv2以降で検討。MVPでは固定幅で実装。

**理由**:
1. **開発者ターゲット親和性**: VS Code/IDEライクな3パネル構成
2. **即時フィードバック**: Code編集→Preview反映の視認性確保
3. **ユーザースキル対応**: モード切替で非コーダー〜上級者をカバー
4. **明確なレイアウト定義**: 実装時の曖昧さを排除

**却下した選択肢**:

| 選択肢 | 却下理由 |
|--------|---------|
| 2パネル構成（Code+Preview）| GUI操作の余地がない、非コーダー対応困難 |
| リサイズ可能パネル（MVP）| 実装複雑化、レイアウト崩れリスク |
| フローティングパネル | 配置管理複雑、ドラッグ操作と競合 |

**関連TD**:
- TD-016（ホーム画面サイドバー - 別画面の決定）
- TD-017（GUIパネルの図表タイプ別動的切り替え）
- TD-018（パネル間同期アーキテクチャ）
- TD-019（3層操作UI構造）
- TD-021（パネルモード切替機構）

---

**次のレビュー予定**: 2025-12-28
