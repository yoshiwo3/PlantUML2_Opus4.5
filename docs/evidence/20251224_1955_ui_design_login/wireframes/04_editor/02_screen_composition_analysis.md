# エディタ画面構成 ベストプラクティス分析

**作成日時**: 2025-12-28 18:00
**最終更新**: 2025-12-29（Session 13 Phase 8 - 階層的憲法システム追加）
**対象**: #04 エディタ画面
**分析対象TD**: TD-017〜TD-033（エディタ画面関連）
**重要更新**: **5機能をv1.1延期** - TD-024, 025, 026, 029, 031（TD-017, 028はMVP復帰）

---

## 1. 分析目的

TD-017〜TD-032で決定された画面構成がベストプラクティスに適合しているかを評価し、改善点を特定する。

### 1.1 TD一覧（Session 13 Phase 4更新）⚡

| TD | タイトル | セッション | 優先度 |
|:--:|---------|:----------:|:------:|
| **TD-017** | GUIパネルの図表タイプ別動的切り替え | 12 | **MVP** ⚡復帰 |
| TD-018 | パネル間同期アーキテクチャ | 12 | MVP |
| TD-019 | **2層統合モーダル構造** ⚡v2.1（セクション折りたたみ追加） | 12→**13** | MVP |
| TD-020 | **2レベルGUI編集構造** ⚡v2.0 | 12→**13** | MVP |
| TD-021 | パネルモード切替機構 | 12 | MVP |
| TD-022 | GUIパネル内部構成（シーケンス図） | 12 | MVP |
| TD-023 | エディタ画面基本レイアウト | 12 | MVP |
| **TD-024** | **Undo/Redo機能** | **13** | **⏸️ v1.1延期** |
| **TD-025** | **WCAG 2.1 AA準拠** | **13** | **⏸️ v1.1延期** |
| **TD-026** | **オンボーディング機能** | **13** | **⏸️ v1.1延期** |
| **TD-027** | **編集状態表示** | **13** | MVP |
| **TD-028** | **AIコード適用機能** | **13** | **MVP** ⚡復帰 |
| **TD-029** | **ローカルバックアップ機構** ⚡v1.1（復元UI詳細追加） | **13** | **⏸️ v1.1延期** |
| **TD-030** | **Previewパネルズーム機能** | **13** | MVP |
| **TD-031** | **ダークモード対応** | **13** | **⏸️ v1.1延期** |
| **TD-032** | **AIチャットパネル折りたたみ** | **13** | MVP |
| **TD-033** | **キーボードショートカットヘルプ** ⚡新規 | **13** | MVP |

### 1.2 MVP延期機能一覧（5機能）⚡ **Session 13 Phase 5更新**

> **決定日**: 2025-12-29
> **評価基準**: 技術実現性、実装複雑度、リスク、MVP適合性、仕様完成度（各20点、計100点）
> **Phase 5更新**: TD-017, TD-028をMVP復帰（12機能に拡大）

| TD | 機能名 | スコア | 評価 | 延期理由 | 代替対応 |
|:--:|--------|:------:|:----:|----------|----------|
| **024** | Undo/Redo | 60 | D | GUI/Code/AIの統一履歴管理が困難 | MVP: ブラウザ標準Undo（Monaco内）、v1.1: 統合実装 |
| **025** | WCAG準拠 | 61 | D | 78基準全対応は過剰（AA準拠の最小実装で十分） | MVP: 基本キーボード操作、v1.1: 監査ツール対応 |
| **026** | オンボーディング | 70 | C | UIが安定する前のガイドは修正コスト高 | MVP: ヘルプページ、v1.1: インタラクティブツアー |
| **029** | ローカルバックアップ | 75 | C | Supabase保存が正式手段、ローカルは補助的 | MVP: Supabase自動保存、v1.1: ローカルキャッシュ |
| **031** | ダークモード | 68 | D | PlantUML SVGのテーマ問題（skinparamとの整合性）未解決 | MVP: ライトモード固定、v1.1: テーマ対応 |

**スコア凡例**:
| スコア | 評価 | 判定 |
|:------:|:----:|------|
| 90-100 | A | MVP必須 |
| 80-89 | B | MVP推奨 |
| 70-79 | C | MVP任意（延期可） |
| 60-69 | D | v1.1延期推奨 |
| <60 | F | v1.1延期必須 |

### 1.3 MVP実装機能一覧（12機能）⚡ **Phase 5更新**

| TD | 機能名 | スコア | 評価 | MVP必須理由 |
|:--:|--------|:------:|:----:|-------------|
| **017** | **GUI動的切り替え** | **80** | **B** | **Registry Patternで実現可能、拡張性確保** ⚡復帰 |
| 018 | パネル間同期 | 88 | B | 3パネル構成の基盤、リアルタイムプレビュー必須 |
| 019 | 2層統合モーダル | 85 | B | GUI編集のコア機能 |
| 020 | 2レベルGUI編集 | 83 | B | 操作一貫性の基盤 |
| 021 | パネルモード切替 | 85 | B | ユーザータイプ対応の基本機能 |
| 022 | GUIパネル内部構成 | 80 | B | シーケンス図GUI編集の基盤 |
| 023 | 基本レイアウト | 90 | A | エディタ画面の根幹 |
| 027 | 編集状態表示 | 82 | B | データ喪失防止の最小対策 |
| **028** | **AIコード適用** | **80** | **B** | **Monaco API整備済み、AI機能の中核** ⚡復帰 |
| 030 | Previewズーム | 78 | C | 大規模図表確認に必要 |
| 032 | AIチャット折りたたみ | 80 | B | 画面スペース確保 |
| 033 | ショートカットヘルプ | 85 | B | 学習支援の最小対策 |

---

## 2. 現在の画面構成（TD決定事項ベース）

### 2.1 基本レイアウト（TD-023: エディタ画面基本レイアウト）

> **TD-023**: エディタ画面の基本レイアウト定義。1920×1080を基準解像度とし、3パネル（GUI 300px / Code 650px / Preview 962px）＋ボトムAIチャットで構成。

#### モード1: GUI+Code（デフォルト）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ ヘッダー                                    [GUI+Code] [GUI] [Code] ← 新規 │
├────────┬─────────────┬──────────────────────────────────────────────────────┤
│ GUI    │ Code        │ Preview                                              │
│ Panel  │ Panel       │ Panel                                                │
│ 300px  │ 650px       │ 962px                                                │
│        │ (Monaco)    │ (PlantUML SVG)                                       │
│ 5セク  │             │                                                      │
│ ション │             │                                                      │
├────────┴─────────────┴──────────────────────────────────────────────────────┤
│ AIチャットパネル（ボトム）                                                   │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### モード2: GUIのみ（非コーダー向け）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ ヘッダー                                    [GUI+Code] [GUI] [Code]         │
├────────────────────────────────┬────────────────────────────────────────────┤
│ GUIパネル（拡張）               │ Preview                                    │
│ 950px                          │ 962px                                      │
│                                │                                            │
│ ← Codeは内部で維持（非表示）    │                                            │
├────────────────────────────────┴────────────────────────────────────────────┤
│ AIチャットパネル                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### モード3: Codeのみ（上級者向け）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ ヘッダー                                    [GUI+Code] [GUI] [Code]         │
├────────────────────────────────┬────────────────────────────────────────────┤
│ Codeパネル（拡張）              │ Preview                                    │
│ 950px                          │ 962px                                      │
│ (Monaco Editor)                │                                            │
├────────────────────────────────┴────────────────────────────────────────────┤
│ AIチャットパネル                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 GUIパネル内部構造（TD-019 層1）⚡ **v2.1更新**

> **v2.1更新（2025-12-29）**: 5セクション構成の折りたたみ式アコーディオン設計

| セクション | デフォルト状態 | 使用頻度 |
|-----------|:------------:|:--------:|
| 1. 参加者 | **展開** | 高 |
| 2. メッセージ表示 | **展開** | 高 |
| 3. Note追加 | 折りたたみ | 中 |
| 4. フラグメント | 折りたたみ | 中 |
| 5. 補助要素 | 折りたたみ | 低 |

```
┌──────────────────────────────┐
│ ▼ Section 1: 参加者          │ ← デフォルト展開
│ ┌──────────────────────────┐ │
│ │ [Alice] [Bob] [+追加]    │ │
│ └──────────────────────────┘ │
├──────────────────────────────┤
│ ▼ Section 2: メッセージ表示  │ ← デフォルト展開
│ ┌──────────────────────────┐ │
│ │ 1. Alice→Bob: hello      │ │
│ │ 2. Bob→Alice: hi         │ │
│ │ [シーケンス編集を開く]    │ │ → 層2統合モーダルへ
│ └──────────────────────────┘ │
├──────────────────────────────┤
│ ▶ Section 3: Note追加        │ ← クリックで展開
├──────────────────────────────┤
│ ▶ Section 4: フラグメント    │ ← クリックで展開
├──────────────────────────────┤
│ ▶ Section 5: 補助要素        │ ← クリックで展開
└──────────────────────────────┘
     300px（モード1）
     950px（モード2）
```

**設計根拠**:
- **視認性向上**: 折りたたみにより300pxでも主要セクションが見やすい
- **操作効率**: 高頻度セクション（1, 2）はデフォルト展開
- **段階的開示**: 低頻度機能は必要時のみ展開

### 2.3 2層統合モーダル構造（TD-019 v2.0）⚡ **Session 13で更新**

> **v1.0（却下）**: 3層構造 → **v2.0（採用）**: 2層統合モーダル

#### 層2: 統合編集モーダル（900×700px）

```
┌─────────────────────────────────────────────────────────────────┐
│ シーケンス編集                                            [×]  │
├─────────────────────────────────────────────────────────────────┤
│ 【参加者管理】                                                  │
│ [Alice] [Bob] [Server] [+追加]                                  │
├─────────────────────────────────────────────────────────────────┤
│ 【メッセージ/ノート一覧】                              [+追加 ▼]│
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ 1. Alice → Bob: リクエスト送信                      [≡][×] │ │
│ │ 2. 📝 note over Alice: 処理開始                     [≡][×] │ │
│ │    └─[展開]────────────────────────────────────────────────┤ │
│ │      │ 種類: [over ▼]  対象: [Alice ▼][+]                 │ │
│ │      │ 内容: [処理開始を記録______]                        │ │
│ │      └─────────────────────────────────────────────────────┤ │
│ │ 3. 🔀 alt [条件: x > 0]                             [≡][×] │ │
│ │    └─[展開]────────────────────────────────────────────────┤ │
│ │      │ 種類: [alt ▼]  条件: [x > 0____]                   │ │
│ │      │ 内包メッセージ:                                     │ │
│ │      │   3-1. Bob → Server: 処理A                  [≡][×] │ │
│ │      │   [+ メッセージ追加]                                │ │
│ │      │ [+ else追加]                                        │ │
│ │      └─────────────────────────────────────────────────────┤ │
│ │ 4. Bob → Alice: レスポンス                          [≡][×] │ │
│ └─────────────────────────────────────────────────────────────┘ │
│                                                                 │
│                                          [キャンセル] [適用]   │
└─────────────────────────────────────────────────────────────────┘
```

**v2.0の特徴**:
- **展開式インライン編集**: フラグメント/Noteをモーダル内で展開編集（別モーダル不要）
- **コンテキスト維持**: 全体一覧を見ながら詳細編集可能
- **入れ子モーダルなし**: モーダル疲れを回避

#### 対応フラグメント一覧（v2.0）

| フラグメント | 展開時の編集項目 |
|-------------|-----------------|
| `alt` | 条件式、内包メッセージ、else追加 |
| `opt` | 条件式、内包メッセージ |
| `loop` | ループ条件/回数、内包メッセージ |
| `par` | 並列ブロック追加、各ブロック内メッセージ |
| `break` | 条件式、内包メッセージ |
| `critical` | 内包メッセージ |
| `group` | グループ名、内包メッセージ |

<details>
<summary>v1.0（却下）: 3層モーダル構造</summary>

**層2: メッセージ管理モーダル（900×700px）**
```
┌─────────────────────────────────────────────────────────────────┐
│ メッセージ管理                                            [×]  │
├─────────────────────────────────────────────────────────────────┤
│ 【参加者管理セクション】                                        │
├─────────────────────┬───────────────────────────────────────────┤
│ メッセージ作成      │ 全メッセージ一覧                          │
│ フォーム            │                                           │
│ (350px)             │ ┌─────────────────────────────────────┐   │
│                     │ │ [カード1] Alice→Bob: hello         │   │
│ [フラグメント挿入]  │ │ [カード2] Bob→Alice: hi            │   │
│                     │ │ [カード3] ...                       │   │
│                     │ │         ↕ D&D並べ替え可能           │   │
│                     │ └─────────────────────────────────────┘   │
├─────────────────────┴───────────────────────────────────────────┤
│ 【全体Note（across）管理セクション】                            │
└─────────────────────────────────────────────────────────────────┘
```

**層3: フラグメント編集モーダル（700×600px）**
```
┌───────────────────────────────────────────────────────┐
│ フラグメント編集（alt/opt/loop等）              [×]  │
├───────────────────────────────────────────────────────┤
│ 条件1: [condition text        ]                       │
│ ┌─────────────────────────────────────────────────┐   │
│ │ メッセージ1                                     │   │
│ │ メッセージ2                     ↕ D&D可能       │   │
│ └─────────────────────────────────────────────────┘   │
│ [+ else追加]                                          │
├───────────────────────────────────────────────────────┤
│ 条件2 (else): [else condition   ]                     │
│ ┌─────────────────────────────────────────────────┐   │
│ │ メッセージ3                                     │   │
│ └─────────────────────────────────────────────────┘   │
├───────────────────────────────────────────────────────┤
│ フラグメントNote: [                ]                  │
│                                    [適用] [キャンセル]│
└───────────────────────────────────────────────────────┘
```

**却下理由**: 3層はUXベストプラクティス違反（2層が限界）、認知負荷高、D評価（65点）
</details>

### 2.4 2レベルGUI編集構造（TD-020 v2.0）⚡ **Session 13で更新**

> **v1.0（却下）**: 3レベル構造 → **v2.0（採用）**: 2レベル統一構造

| レベル | 操作 | 対象要素 | UI実装 |
|:------:|------|---------|--------|
| **Level 1** | 直接操作 | 追加/削除/並替 | クリック、D&D、右クリックメニュー |
| **Level 2** | 展開式編集 | 内容/設定変更 | インライン展開、フォーム入力 |

**要素別対応表**:

| 要素 | Level 1（直接操作） | Level 2（展開式編集） |
|------|:------------------:|:--------------------:|
| **参加者** | 追加/削除/並替 | 名前編集 |
| **メッセージ** | 追加/削除/並替 | 内容/矢印種類編集 |
| **Fragment** | 追加/削除/並替 | 種類/条件/内包メッセージ編集 |
| **Note** | 追加/削除/並替 | 種類/対象参加者/内容編集 |
| **補助要素** | 追加/削除/並替 | タイトル/数値編集 |

**Note対応詳細（v2.0追加）**:

| Note種類 | PlantUML構文 | Level 1操作 | Level 2編集項目 |
|---------|-------------|------------|----------------|
| 参加者Note | `note left/right of <参加者>` | 右クリック→追加 | 種類、対象、内容 |
| メッセージNote | `note left/right` | [Note+]ボタン | 位置、内容 |
| 範囲Note | `note over <A>, <B>` | 右クリック→追加 | 対象参加者（複数）、内容 |
| 全体Note | `note across` | [+追加]ボタン | 内容 |
| 六角形Note | `hnote over` | 種類変更で対応 | 形状、対象、内容 |
| 四角形Note | `rnote over` | 種類変更で対応 | 形状、対象、内容 |
| 複数行Note | `note ... end note` | 自動判定 | 内容（複数行対応） |

**v2.0の利点**:
- **操作の一貫性**: 全要素が同じ2レベル操作パターン
- **学習コスト低減**: 直感的な2択のみ
- **混乱回避**: 「なぜ編集できないのか」問題を解消

<details>
<summary>v1.0（却下）: 3レベル構造</summary>

| レベル | 対象構文 | GUIパネルでの表示・操作 |
|:------:|---------|------------------------|
| **1** | message, participant, note, fragment, 補助要素 | フォーム、D&D、モーダル |
| **2** | skinparam, title, header, footer, autonumber | クリック → ポップオーバー → テキスト入力 |
| **3** | !include, !define, !ifdef, box, newpage | 折りたたみ表示 → 展開でコード断片 → 「Codeで編集」リンク |

**却下理由**: 3種類の編集体験は混乱を招く、ユーザー期待との乖離、C評価（75点）
</details>

### 2.5 ヘッダー構成（TD-021）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ [Logo] PlantUML Studio │ ファイル名.puml │ [保存] [エクスポート] ... │ [■■□] │
└─────────────────────────────────────────────────────────────────────────────┘
                                                                      ↑
                                                            パネルモード切替トグル
                                                            [GUI+Code][GUI][Code]
```

**キーボードショートカット**: Ctrl+1, Ctrl+2, Ctrl+3

### 2.6 パネル間同期（TD-018）

```
        0ms（即時）           500ms（デバウンス）
GUIパネル ─────────→ Codeパネル ─────────────────→ Previewパネル
    ↑                    │
    └────────────────────┘
         300ms（デバウンス）
```

**エラー行ハイライト（TD-018 Session 13追加）**:
- Monaco Editorのデコレーション機能でエラー行を視覚的にハイライト
- ガター（行番号横）に赤い●アイコン表示
- ホバーでエラーメッセージ表示

### 2.7 Session 13追加機能

#### 2.7.1 Undo/Redo機能（TD-024）

| 項目 | 仕様 |
|------|------|
| 実装パターン | Command Pattern |
| 履歴保持数 | 最大100件 |
| ショートカット | `Ctrl+Z` / `Ctrl+Shift+Z` |

#### 2.7.2 アクセシビリティ（TD-025）

| カテゴリ | 対応内容 |
|---------|---------|
| 知覚可能 | コントラスト比4.5:1以上（WCAG AA） |
| 操作可能 | 全機能キーボード操作可能 |
| 理解可能 | 一貫したナビゲーション |
| 堅牢 | ARIA属性、セマンティックHTML |

#### 2.7.3 オンボーディング（TD-026）

- 初回ログイン時にステップバイステップツアー表示
- 7ステップ（ホーム→新規図表→エディタ→GUI→Code→Preview→AIチャット）
- スキップ可能、設定から再表示可能

#### 2.7.4 編集状態表示（TD-027）

```
┌─────────────────────────────────────────────────────────────┐
│ [Logo] │ sequence_diagram.puml ● 未保存 │ [保存] [Export] ... │
└─────────────────────────────────────────────────────────────┘
```

| 状態 | アイコン | 色 |
|------|---------|-----|
| 保存済み | ✓ | グレー |
| 未保存 | ● | オレンジ |
| 保存中 | ⟳ | ブルー |
| エラー | ⚠ | レッド |

#### 2.7.5 AIコード適用（TD-028）

```
┌─────────────────────────────────────────────┐
│ 🤖 AI:                                      │
│ ┌─────────────────────────────────────────┐ │
│ │ loop 認証リトライ                       │ │
│ │   User -> Auth: 認証要求                │ │
│ │ end                                     │ │
│ │ [📋 コピー] [▶ 適用] [👁 差分を見る]     │ │
│ └─────────────────────────────────────────┘ │
└─────────────────────────────────────────────┘
```

- 「適用」ボタンでCodeパネルに反映
- 適用前に差分プレビュー表示可能
- Undo可能（TD-024連携）

#### 2.7.6 ローカルバックアップ（TD-029）

| 項目 | 仕様 |
|------|------|
| 保存タイミング | 編集から30秒後（デバウンス） |
| 有効期間 | 7日経過で自動削除 |
| 容量管理 | 図表ごとに最新5件保持 |
| 復元UI | 「復元可能なバックアップがあります」通知 |

#### 2.7.7 Previewズーム（TD-030）

```
┌─────────────────────────────────────┐
│ Preview                    [−][+][Fit][1:1] 150% │
├─────────────────────────────────────┤
│         (SVG表示エリア)              │
└─────────────────────────────────────┘
```

| 操作 | 動作 |
|------|------|
| `Ctrl+ホイール` | ズームイン/アウト |
| `[Fit]` | パネルサイズにフィット |
| `[1:1]` | 100%表示 |
| ドラッグ | パン（位置移動） |

#### 2.7.8 ダークモード（TD-031）

| 要素 | ライトモード | ダークモード |
|------|-------------|-------------|
| 背景（メイン） | `#FFFFFF` | `#1E1E1E` |
| 背景（パネル） | `#F5F5F5` | `#252526` |
| テキスト | `#333333` | `#CCCCCC` |

- ヘッダーにトグルボタン配置
- システム設定（`prefers-color-scheme`）に追従
- localStorage に設定永続化

#### 2.7.9 AIチャット折りたたみ（TD-032）

**展開時**:
```
├───────────┴───────────┴─────────────────────┤
│ AI Chat                              [▼]    │ ← 高さ: 200px
└─────────────────────────────────────────────┘
```

**折りたたみ時**:
```
├───────────┴───────────┴─────────────────────┤
│ AI Chat [▲]                                 │ ← 高さ: 32px（バー表示のみ）
└─────────────────────────────────────────────┘
```

- `Ctrl+Shift+A` で切り替え
- 状態はlocalStorageに永続化

#### 2.7.10 キーボードショートカットヘルプ（TD-033）⚡ **新規追加**

> **追加日**: 2025-12-29（機能提供方法評価による改善）

**起動方法**:
- `?`キー押下
- ヘッダーの`?`アイコンクリック

**ヘルプモーダル**:
```
┌────────────────────────────────────────────────┐
│ キーボードショートカット                   [×] │
├────────────────────────────────────────────────┤
│ パネルモード                                   │
│ │ Ctrl+1    GUI+Code モード                   │
│ │ Ctrl+2    GUI のみモード                    │
│ │ Ctrl+3    Code のみモード                   │
│                                                │
│ 編集操作                                       │
│ │ Ctrl+S    保存                              │
│ │ Ctrl+Z    元に戻す                          │
│ │ Ctrl+Shift+Z やり直し                       │
│                                                │
│ UI操作                                         │
│ │ Ctrl+Shift+A AIチャット折りたたみ           │
│ │ ?         このヘルプを表示                  │
│                                                │
│ プレビュー                                     │
│ │ Ctrl+0    フィット表示                      │
│ │ Ctrl++/-  ズームイン/アウト                 │
└────────────────────────────────────────────────┘
```

**ツールチップ表示**: 各ボタンホバー時にショートカットを表示

### 2.8 キーボードショートカット一覧（TD-021拡張 + TD-033）

| カテゴリ | ショートカット | 動作 |
|---------|---------------|------|
| パネルモード | `Ctrl+1` | モード1（GUI+Code） |
| パネルモード | `Ctrl+2` | モード2（GUIのみ） |
| パネルモード | `Ctrl+3` | モード3（Codeのみ） |
| 編集操作 | `Ctrl+S` | 保存 |
| 編集操作 | `Ctrl+Z` | Undo |
| 編集操作 | `Ctrl+Shift+Z` | Redo |
| UI操作 | `Ctrl+Shift+A` | AIチャット折りたたみ/展開 |
| **ヘルプ** | **`?`** | **ショートカットヘルプ表示** ⚡新規 |
| プレビュー | `Ctrl+0` | Previewフィット表示 |
| プレビュー | `Ctrl++` | Previewズームイン |
| プレビュー | `Ctrl+-` | Previewズームアウト |
| モーダル | `Esc` | モーダルを閉じる |

---

## 3. 評価フレームワーク

| 観点 | 評価基準 |
|------|---------|
| UXベストプラクティス | 業界標準、認知負荷、操作効率 |
| ターゲットユーザー適合性 | ペルソナ（非コーダー〜上級者） |
| 競合ツール比較 | VS Code, Figma, Mermaid Live Editor等 |
| 技術的実現可能性 | 実装複雑度、パフォーマンス |
| アクセシビリティ | WCAG準拠、キーボード操作 |
| レスポンシブ対応 | 解像度別対応 |

### 採点基準

| スコア | 評価 | 定義 |
|:------:|:----:|------|
| 90-100 | A | ベストプラクティス完全準拠 |
| 80-89 | B | 軽微な改善余地あり |
| 70-79 | C | 中程度の問題あり、要改善 |
| 60-69 | D | 重大な問題あり、必須修正 |
| <60 | F | 設計見直し必要 |

---

## 4. 各要素の詳細評価

### 4.1 3パネルレイアウト（GUI + Code + Preview）

| 評価項目 | スコア | 詳細 |
|---------|:------:|------|
| 関心の分離 | ✅ | 編集（GUI/Code）と出力（Preview）の明確な分離 |
| ユーザースキル対応 | ✅ | 非コーダー（GUI）〜上級者（Code）をカバー |
| スペース効率 | ⚠️ | **300pxのGUIパネルは狭い** |

**競合比較**（※2025年12月時点の公式ドキュメント参照）:

| ツール | レイアウト | 備考 |
|--------|-----------|------|
| VS Code | サイドバー(250-300px) + エディタ + パネル | リサイズ可能 |
| Figma | 左パネル + キャンバス + 右パネル | 左右パネルは折りたたみ可能 |
| Mermaid Live | 2パネル（Code + Preview）| シンプル |
| PlantUML Server | 2パネル（Code + Preview）| シンプル |

**問題点**:
- **300px幅は業界標準の下限**。複雑なGUI操作には不足
- 1920px幅で3パネル＋AIチャットは情報密度が高い

**評価: 85/100**（-15: GUIパネル幅の制約）

---

### 4.2 パネルモード切替（3モード）

| 評価項目 | スコア | 詳細 |
|---------|:------:|------|
| 柔軟性 | ✅ | ユーザータイプ別に最適化可能 |
| 発見可能性 | ⚠️ | トグルボタンが目立たない可能性 |
| 認知負荷 | ⚠️ | モード切替の学習コスト |

**代替案との比較**:

| アプローチ | メリット | デメリット |
|-----------|---------|-----------|
| **固定3モード（現行案）** | シンプル、予測可能 | 柔軟性不足 |
| リサイズ可能パネル | 完全な柔軟性 | 実装複雑、レイアウト崩れリスク |
| 折りたたみ式パネル | 中間的柔軟性 | 状態管理が複雑 |

**評価: 90/100**（-10: 発見可能性の懸念）

---

### 4.3 2層統合モーダル構造 ✅ **Session 13でv2.0に更新**

| 評価項目 | v1.0スコア | v2.0スコア | 詳細 |
|---------|:----------:|:----------:|------|
| 幅制約の解決 | ✅ | ✅ | 300px制約を900pxモーダルで解消 |
| 操作階層 | ❌ | ✅ | **2層に削減、適正範囲** |
| コンテキスト維持 | ❌ | ✅ | 展開式で一覧表示を維持 |
| 戻り操作 | ❌ | ✅ | **展開/折りたたみで完結** |

**v2.0の改善点**:

| 問題 | v1.0（3層） | v2.0（2層） |
|------|-----------|-----------|
| モーダル疲れ | 3層の入れ子 | 入れ子なし、展開式 |
| コンテキスト喪失 | Preview見えず | 一覧を見ながら編集 |
| 操作効率 | 層を行き来 | 展開/折りたたみで完結 |
| 認知負荷 | 高（3階層理解必要） | 低（2層で完結） |

<details>
<summary>v1.0（却下）の評価詳細</summary>

**業界ベストプラクティスとの乖離**:

| パターン | 使用例 | 評価 |
|---------|--------|------|
| **センターモーダル** | 確認ダイアログ、設定 | 1-2層が限界 |
| **スライドオーバー** | Notion, Linear, Figma | コンテキスト維持、推奨 |
| **ドロワー** | Material Design | 部分的なコンテンツ表示 |
| **インプレース編集** | Figma | 最もシームレス |

**v1.0の問題点**:
1. **モーダル疲れ**: 3層のモーダルはユーザーを「閉じ込められた」感覚にさせる
2. **コンテキスト喪失**: メインのPreviewが見えなくなる
3. **操作効率低下**: 層を行き来する操作が多発

**v1.0評価: 65/100**（-35: UXベストプラクティスからの乖離）
</details>

**評価: 85/100**（v1.0: 65点 → v2.0: +20点改善）

---

### 4.4 2レベルGUI編集構造 ✅ **Session 13でv2.0に更新**

| 評価項目 | v1.0スコア | v2.0スコア | 詳細 |
|---------|:----------:|:----------:|------|
| 技術的合理性 | ✅ | ✅ | 構文カテゴリに応じた分類 |
| 一貫性 | ❌ | ✅ | **全要素で統一パターン** |
| 学習コスト | ⚠️ | ✅ | **直感的な2択のみ** |

**v2.0の改善点**:

```
v1.0のユーザー視点:
「なぜLevel 3は編集できないの？」

v2.0のユーザー視点:
「追加/削除はクリック、詳細編集は展開」← 統一パターン
```

| 操作 | v1.0（3レベル） | v2.0（2レベル） |
|------|----------------|----------------|
| 追加/削除 | Level 1のみ | **全要素でLevel 1** |
| 詳細編集 | Level 1: フォーム、Level 2: ポップオーバー、Level 3: 不可 | **全要素でLevel 2（展開式）** |

<details>
<summary>v1.0（却下）の評価詳細</summary>

**ユーザー視点の問題**:
```
ユーザーの期待:
「GUIで全部編集できるはず」

現実:
- Level 1: フォーム編集 ✓
- Level 2: ポップオーバー編集 △（異なるUX）
- Level 3: 編集不可、Codeへ誘導 ✗（期待はずれ）
```

**v1.0評価: 75/100**（-25: 一貫性の欠如）
</details>

**評価: 85/100**（v1.0: 75点 → v2.0: +10点改善）

---

### 4.5 パネル間同期（TD-018）

| 評価項目 | スコア | 詳細 |
|---------|:------:|------|
| アーキテクチャ | ✅ | Codeを正のソースとする設計は堅牢 |
| タイミング定義 | ✅ | 0ms/300ms/500msは業界標準 |
| 体感遅延 | ⚠️ | 300ms遅延は知覚可能 |

**評価: 95/100**（-5: 遅延の知覚可能性）

---

### 4.6 AIチャットパネル（ボトム）✅ **Session 13で解決**

| 評価項目 | スコア | 詳細 |
|---------|:------:|------|
| アクセス性 | ✅ | 常時表示で即座にアクセス可能 |
| スペース効率 | ✅ | **TD-032で折りたたみ機能追加済み** |
| 配置 | ✅ | ボトム配置はチャットUIの標準 |
| AIコード適用 | ✅ | **TD-028で「適用」ボタン + 差分プレビュー定義済み** |

**Session 13で解決済み**:
- ~~固定表示は編集スペースを圧迫~~ → TD-032で折りたたみ可能に
- ~~使用頻度が低い場合、無駄なスペース消費~~ → 折りたたみ時は32pxのみ

**評価: 95/100**（+15: 折りたたみ機能追加、AIコード適用機能追加）

---

### 4.7 レスポンシブ対応 ✅ **TD-023で定義済み**

| ブレークポイント | レイアウト | パネル幅 |
|-----------------|-----------|---------|
| ≥1920px | 3パネル | GUI 300px + Code 650px + Preview 962px |
| 1440-1919px | 3パネル（縮小）| GUI 250px + Code 500px + Preview 自動 |
| 1280-1439px | 2パネル | Code + Preview（GUI非表示推奨）|
| <1280px | 1パネル or タブ切替 | 単一パネル表示 |

**TD-023で定義済み**:
- 4ブレークポイントで段階的にレイアウト調整
- 小画面ではパネルモード2/3を推奨

**評価: 90/100**（+40: TD-023でレスポンシブ定義追加）

---

### 4.8 アクセシビリティ ✅ **TD-025で定義済み**

| 要件 | 現状 | TD参照 |
|------|------|--------|
| キーボードショートカット | ✅ 11種定義 | TD-021拡張 |
| フォーカス管理 | ✅ モーダル内フォーカストラップ定義 | TD-025 |
| スクリーンリーダー | ✅ ARIA属性、セマンティックHTML | TD-025 |
| 色コントラスト | ✅ WCAG AA 4.5:1以上 | TD-025, TD-031 |
| キーボードナビゲーション | ✅ Tab/Shift+Tab/Enter/Esc | TD-025 |

**TD-025で定義済み**:
- WCAG 2.1 AAレベル準拠
- 知覚可能・操作可能・理解可能・堅牢の4原則対応
- ダークモード対応（TD-031）でコントラスト比を両テーマで確保

**評価: 90/100**（+50: TD-025でアクセシビリティ定義追加）

---

### 4.9 データ安全性（Session 13追加）

| 評価項目 | スコア | TD参照 | 詳細 |
|---------|:------:|:------:|------|
| Undo/Redo | ✅ | TD-024 | Command Pattern、100件履歴 |
| 編集状態表示 | ✅ | TD-027 | 未保存/保存中/エラー状態の可視化 |
| ローカルバックアップ | ✅ | TD-029 | 30秒デバウンス、7日保持 |
| 離脱防止 | ✅ | TD-027 | `beforeunload`イベントで警告 |

**評価: 95/100**（データ喪失リスクを最小化する包括的な設計）

---

### 4.10 Previewパネル操作性（Session 13追加）

| 評価項目 | スコア | TD参照 | 詳細 |
|---------|:------:|:------:|------|
| ズーム機能 | ✅ | TD-030 | 25%〜400%、ボタン+ホイール対応 |
| フィット表示 | ✅ | TD-030 | ワンクリックでパネルサイズに調整 |
| パン操作 | ✅ | TD-030 | ドラッグで位置移動 |
| ズーム値表示 | ✅ | TD-030 | 現在のズーム率を数値表示 |

**評価: 95/100**（大規模図表の確認に必要な機能を網羅）

---

### 4.11 視覚的カスタマイズ（Session 13追加）

| 評価項目 | スコア | TD参照 | 詳細 |
|---------|:------:|:------:|------|
| ダークモード | ✅ | TD-031 | ライト/ダーク切替 |
| システム設定追従 | ✅ | TD-031 | `prefers-color-scheme`対応 |
| カラーパレット定義 | ✅ | TD-031 | 6色定義（背景/テキスト/アクセント等）|
| Monaco Editor連携 | ✅ | TD-031 | `vs`/`vs-dark`テーマ切替 |

**評価: 95/100**（長時間作業の目の疲労を軽減する設計）

---

### 4.12 ユーザー導入支援（Session 13追加）

| 評価項目 | スコア | TD参照 | 詳細 |
|---------|:------:|:------:|------|
| オンボーディング | ✅ | TD-026 | 7ステップツアー |
| スキップ機能 | ✅ | TD-026 | 即座にスキップ可能 |
| 再表示機能 | ✅ | TD-026 | 設定から再開可能 |
| 進捗保存 | ✅ | TD-026 | Supabase保存（デバイス間同期）|

**評価: 90/100**（初回ユーザーの学習曲線を緩和）

---

### 4.13 エラーフィードバック（Session 13追加）

| 評価項目 | スコア | TD参照 | 詳細 |
|---------|:------:|:------:|------|
| エラー行ハイライト | ✅ | TD-018追加 | Monaco Editorデコレーション |
| ガターマーカー | ✅ | TD-018追加 | 行番号横に赤●アイコン |
| ホバーメッセージ | ✅ | TD-018追加 | エラー内容をツールチップ表示 |
| 複数エラー対応 | ✅ | TD-018追加 | すべてのエラー行を同時表示 |

**評価: 95/100**（構文エラーの即座の認識と修正を支援）

---

## 5. 総合評価

### 5.1 Session 12→13項目（v2.0更新後）

| 項目 | Session 12 | Session 13 Phase 1 | Session 13 Phase 2 | 評価 |
|------|:----------:|:------------------:|:------------------:|:----:|
| 3パネルレイアウト | 85 | 85 | 85 | B |
| パネルモード切替 | 90 | 90 | 90 | A |
| **モーダル構造** | 65 (3層) | 65 (3層) | **85 (2層v2.0)** | **B** ⬆️ |
| **GUI編集レベル** | 75 (3レベル) | 75 (3レベル) | **85 (2レベルv2.0)** | **B** ⬆️ |
| パネル間同期 | 95 | 95 | 95 | A |
| AIチャットパネル | 80 | **95** | 95 | A |
| レスポンシブ対応 | 50 | **90** | 90 | A |
| アクセシビリティ | 40 | **90** | 90 | A |

### 5.2 Session 13追加項目

| 項目 | スコア | 評価 | TD |
|------|:------:|:----:|:--:|
| データ安全性 | 95 | A | TD-024,027,029 |
| Previewパネル操作性 | 95 | A | TD-030 |
| 視覚的カスタマイズ | 95 | A | TD-031 |
| ユーザー導入支援 | 90 | A | TD-026 |
| エラーフィードバック | 95 | A | TD-018追加 |

### 5.3 総合スコア

**総合スコア: 90.38/100（単純平均、評価A）** ⚡ **v2.0更新で達成**

> 計算方法: (85+90+85+85+95+95+90+90+95+95+95+90+95) / 13 = 1175 / 13 = 90.38

### 5.4 スコア改善サマリー

| 指標 | Session 12 | Session 13 Phase 1 | Session 13 Phase 2 | 改善 |
|------|:----------:|:------------------:|:------------------:|:----:|
| 総合スコア | 72.5 | 88.85 | **90.38** | **+17.88** |
| 評価 | C | B | **A** | **↑2ランク** |
| D/F評価項目数 | 2 | 2 | **0** | **-2** |
| A評価項目数 | 2 | 9 | **11** | **+9** |

**Phase 2での改善**:
| 項目 | Phase 1 | Phase 2 | 改善点 |
|------|:-------:|:-------:|--------|
| モーダル構造 | 65 (D) | 85 (B) | +20（3層→2層） |
| GUI編集レベル | 75 (C) | 85 (B) | +10（3レベル→2レベル） |

---

## 6. 問題点の解決状況（Session 13 Phase 2更新）

### 6.1 Session 13 Phase 1で解決済み ✅

| 旧問題 | 解決TD | 対応内容 |
|--------|:------:|---------|
| レスポンシブ対応の欠如 | TD-023 | 4ブレークポイント定義済み |
| アクセシビリティの欠如 | TD-025 | WCAG 2.1 AA準拠定義済み |
| AIチャット固定 | TD-032 | 折りたたみ機能追加済み |
| モード切替発見性 | TD-026 | オンボーディング追加済み |

### 6.2 Session 13 Phase 2で解決済み ✅ ⚡ **新規追加**

| 旧問題 | 解決TD | 対応内容 |
|--------|:------:|---------|
| **3層モーダル構造** | TD-019 v2.0 | **2層統合モーダル + 展開式インライン編集** |
| **3レベルGUI編集** | TD-020 v2.0 | **2レベル統一構造（直接操作 + 展開式編集）** |

#### 6.2.1 問題1解決: 3層→2層モーダル構造

**Before（v1.0）**:
```
層1（GUIパネル）→ 層2（メッセージ管理モーダル）→ 層3（フラグメント編集モーダル）
```

**After（v2.0）**:
```
層1（GUIパネル）→ 層2（統合編集モーダル）
                    └─ インライン展開で詳細編集（別モーダル不要）
```

**解決のポイント**:
1. **展開式インライン編集**: フラグメント/Noteをモーダル内で展開（層3を廃止）
2. **コンテキスト維持**: 一覧表示を維持しながら詳細編集
3. **操作効率向上**: 展開/折りたたみで完結、モーダル遷移なし

**評価改善**: 65点（D）→ 85点（B）= **+20点**

#### 6.2.2 問題2解決: 3レベル→2レベルGUI編集

**Before（v1.0）**:
| レベル | 操作 | 問題 |
|:------:|------|------|
| Level 1 | フォーム編集 | OK |
| Level 2 | ポップオーバー | 異なるUX |
| Level 3 | 編集不可→Code誘導 | 期待はずれ |

**After（v2.0）**:
| レベル | 操作 | 統一パターン |
|:------:|------|-------------|
| Level 1 | 追加/削除/並替 | 全要素共通 |
| Level 2 | 展開式編集 | 全要素共通 |

**解決のポイント**:
1. **操作の統一**: 全要素が同じ2レベル操作パターン
2. **学習コスト低減**: 「直接操作 or 展開」の2択のみ
3. **期待との一致**: 「なぜ編集できないのか」問題を解消

**評価改善**: 75点（C）→ 85点（B）= **+10点**

### 6.3 残存する問題点

**なし** ✅

Session 13 Phase 2で全ての重大問題（D/C評価）を解決。
全項目がB評価以上となり、総合スコアがA評価（90.38点）に到達。

---

## 7. 将来検討アクション（v2以降）

> **注記**: Session 13 Phase 2で全ての重大問題を解決。残りは優先度を下げて検討。

### 優先度: 高

**なし** ✅ - Session 13 Phase 2で全て解決済み

### 優先度: 中

| # | 課題 | 検討アクション | 対象TD | 現評価 |
|:-:|------|---------------|--------|:------:|
| 1 | GUIパネル300px | 最小幅を350pxに拡大 | TD-023 | B (85) |
| 2 | スライドオーバー方式 | 将来的により洗練されたUI検討 | TD-019 | B (85) |

### 優先度: 低（Session 13で解決済みの関連項目）

| # | 課題 | 状況 | 対象TD |
|:-:|------|------|--------|
| ~~1~~ | ~~3層モーダル~~ | ✅ 解決済み（v2.0: 2層統合） | TD-019 |
| ~~2~~ | ~~GUI編集レベル混乱~~ | ✅ 解決済み（v2.0: 2レベル統一） | TD-020 |
| ~~3~~ | ~~レスポンシブ未定義~~ | ✅ 解決済み | TD-023 |
| ~~4~~ | ~~アクセシビリティ未定義~~ | ✅ 解決済み | TD-025 |
| ~~5~~ | ~~AIチャット固定~~ | ✅ 解決済み | TD-032 |
| ~~6~~ | ~~モード切替発見性~~ | ✅ 解決済み | TD-026 |
| 7 | 固定モードの制約 | v3検討 | TD-023 |

---

## 8. 改善後の画面構成案（参考）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ ヘッダー                              [GUI+Code] [GUI] [Code]  [?] [設定]  │
├────────┬─────────────┬──────────────────────────────────────────────────────┤
│ GUI    │ Code        │ Preview                                              │
│ Panel  │ Panel       │ Panel                                                │
│ 350px  │ 600px       │ 962px                                                │
│        │ (Monaco)    │                                                      │
│ 5セク  │             │ ┌────────────────────────┐                           │
│ ション │             │ │ スライドオーバー       │ ← 層2相当               │
│        │             │ │ [メッセージ][フラグ]   │   タブで切替            │
│ [編集] │             │ │                        │   Previewは見える       │
│   ↓    │             │ └────────────────────────┘                           │
├────────┴─────────────┴──────────────────────────────────────────────────────┤
│ [▼] AIチャット（折りたたみ可能）                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**変更点**:
1. GUIパネル: 300px → 350px
2. 3層モーダル → スライドオーバー（Preview上に重ねる、1層に削減）
3. フラグメント編集はスライドオーバー内のタブで対応
4. AIチャットは折りたたみ可能

---

## 9. 結論

**Session 13 Phase 2で全問題解決。A評価（90.38点）達成。**

| 評価 | Session 12 | Session 13 Phase 1 | Session 13 Phase 2 |
|------|:----------:|:------------------:|:------------------:|
| **総合スコア** | 72.5/100 (C) | 88.85/100 (B) | **90.38/100 (A)** ⚡ |
| **A評価項目数** | 2 | 9 | **11** |
| **D/F評価項目数** | 2 | 2 | **0** ⚡ |
| **残存問題** | 5件 | 2件 | **0件** ⚡ |

### Session 13 Phase 1での改善点

| 改善内容 | 対応TD |
|---------|--------|
| アクセシビリティ定義 | TD-025 |
| レスポンシブ定義 | TD-023 |
| AIチャット折りたたみ | TD-032 |
| オンボーディング | TD-026 |
| Undo/Redo | TD-024 |
| 編集状態表示 | TD-027 |
| ローカルバックアップ | TD-029 |
| Previewズーム | TD-030 |
| ダークモード | TD-031 |
| AIコード適用 | TD-028 |
| エラー行ハイライト | TD-018追加 |
| キーボードショートカット拡張 | TD-021拡張 |

### Session 13 Phase 2での改善点 ⚡ **新規追加**

| 改善内容 | 対応TD | スコア改善 |
|---------|--------|:---------:|
| **3層→2層モーダル** | TD-019 v2.0 | 65→85 (+20) |
| **3レベル→2レベルGUI編集** | TD-020 v2.0 | 75→85 (+10) |
| **Note対応詳細定義** | TD-020 v2.0 | - |
| **group フラグメント対応** | TD-019 v2.0 | - |

---

## 10. 次のアクション

### 現行構成でMVP進行 ✅ **採用済み・完了**

| 項目 | Session 12 | Session 13 Phase 1 | Session 13 Phase 2 |
|------|-----------|-------------------|-------------------|
| **スコア** | 72.5/100 (C) | 88.85/100 (B) | **90.38/100 (A)** ⚡ |
| **TD範囲** | TD-017〜TD-023 | TD-017〜TD-032 | **同左（v2.0更新）** |
| **残存問題** | 5件 | 2件 | **0件** ⚡ |
| **次のアクション** | 問題解決待ち | 問題解決待ち | **ワイヤーフレーム作成開始** |

### ワイヤーフレーム作成準備完了 ✅

| 準備項目 | 状況 |
|---------|:----:|
| TD-017〜TD-032定義 | ✅ |
| 3層→2層モーダル解決 | ✅ |
| 3レベル→2レベルGUI解決 | ✅ |
| Note対応定義 | ✅ |
| groupフラグメント対応 | ✅ |
| 評価A達成（90点以上） | ✅ |

---

**決定履歴**:
- 2025-12-28 Session 12: 選択肢A採用（3層モーダル維持）、72.5点(C)
- 2025-12-29 Session 13 Phase 1: TD-024〜TD-032追加、88.85点(B)
- 2025-12-29 Session 13 Phase 2: TD-019/TD-020 v2.0更新、**90.38点(A)達成** ⚡
- 2025-12-29 Session 13 Phase 3: TD-019 v2.1/TD-029 v1.1/TD-033新規追加（機能提供方法評価対応）⚡

---

## 更新履歴

| 日時 | バージョン | 内容 |
|------|:----------:|------|
| 2025-12-29 | **v3.2** | **Session 13 Phase 4対応**: MVP延期7機能を明示化（TD-017, 024, 025, 026, 028, 029, 031）。厳格評価（技術実現性・実装複雑度・リスク・MVP適合性・仕様完成度）に基づきMVPスコープを10機能に絞り込み。Section 1.2/1.3追加 |
| 2025-12-29 | v3.1 | Session 13 Phase 3対応: TD-019 v2.1（GUIパネルセクション折りたたみ）、TD-029 v1.1（復元UI詳細）、TD-033新規（キーボードショートカットヘルプ）追加。機能提供方法評価（現実性・視認性・操作性）に基づく改善 |
| 2025-12-29 | v3.0 | **Session 13 Phase 2対応**: TD-019/TD-020をv2.0に更新（3層→2層、3レベル→2レベル）、総合スコア88.85→90.38に改善（A評価達成）、全残存問題解決、Note対応詳細追加、groupフラグメント対応追加、Section 11（議論経緯）追加 |
| 2025-12-29 | v2.0 | **Session 13 Phase 1対応**: TD-017〜TD-032に範囲拡張、評価項目13項目に拡大（+5）、総合スコア72.5→88.85に改善、Section 2.7追加（Session 13機能）、Section 4.9-4.13追加（新評価）、Section 5再計算、Section 6-7解決状況更新 |
| 2025-12-28 22:00 | v1.1 | 9問題対応完了 - TD-017〜TD-023に統一、採点基準追加、加重列削除・単純平均明記、TD-023説明追加、将来検討事項化、選択肢A/B/C詳細化、レスポンシブ根拠追加、選択肢A採用決定 |
| 2025-12-28 18:00 | v1.0 | 初版作成（Session 12 ベストプラクティス分析）|

---

## 11. 議論の経緯（Session 13 Phase 2）

### 11.1 問題認識

Session 13 Phase 1の評価結果（88.85点、B評価）において、以下2件がD/C評価として残存していた：

| 問題 | 評価 | 課題内容 |
|------|:----:|---------|
| TD-019（3層モーダル構造） | D (65点) | 認知負荷高、モーダル入れ子、操作効率低下 |
| TD-020（3レベルGUI編集） | C (75点) | 操作パターン不統一、学習コスト高 |

ユーザーから「残存問題（2件）はMVPで対応するため、今解決する必要があります」との指示があり、Phase 2として解決策を検討した。

### 11.2 TD-019の解決策検討

**問題の本質**:
- 3層（GUIパネル → メッセージ管理モーダル → フラグメント編集モーダル）は深すぎる
- UXベストプラクティスでは**2層が限界**
- モーダル入れ子によるコンテキスト喪失

**検討した選択肢**:

| 案 | 概要 | 評価 |
|:--:|------|:----:|
| A | 3層維持（現状） | D (65点) |
| B | タブ統合モーダル | B見込み |
| C | スライドオーバー | B見込み |
| D | インプレース編集 | 複雑すぎ |
| **E** | **2層統合モーダル（展開式フラグメント編集）** | **採用** |

**案E採用理由**:
1. **層3を展開式に統合**: フラグメント編集を層2内のインライン展開で対応
2. **実装シンプル**: 既存のモーダル構造を活かせる
3. **コンテキスト維持**: 一覧を見ながら詳細編集可能
4. **操作一貫性**: 全要素が同じ「展開→編集」パターン

### 11.3 TD-020の解決策検討

**問題の本質**:
- 3レベル（完全GUI / ポップオーバー / 読取専用）で操作が不統一
- 「なぜLevel 3は編集できないのか」というユーザー混乱

**検討した選択肢**:

| 案 | 概要 | 評価 |
|:--:|------|:----:|
| A | 3レベル維持 | C (75点) |
| B | 視覚的インジケータ追加 | C見込み |
| C | Level 3をポップオーバー化 | やや複雑 |
| **D** | **2レベル簡素化（直接操作 + 展開式編集）** | **採用** |

**案D採用理由**:
1. **全要素で統一パターン**: Level 1（直接操作）とLevel 2（展開式編集）の2択
2. **学習コスト低**: 「追加/削除はクリック、詳細編集は展開」という直感的ルール
3. **期待との一致**: 全要素がGUIで編集可能

### 11.4 groupフラグメントの対応確認

ユーザー質問: 「groupはLevel1で対応できるの？」

**回答**: YES。`group`は他のフラグメント（alt, opt, loop等）と構造的に同じ。
- Level 1: 追加/削除/並替（D&D）
- Level 2: グループ名編集、内包メッセージ編集

### 11.5 Note対応の詳細定義

ユーザー質問: 「noteへの対応は？」

**回答**: 全Note種類を2レベル構造で対応。

| Note種類 | Level 1 | Level 2 |
|---------|---------|---------|
| `note left/right of` | 右クリック→追加 | 種類、対象、内容編集 |
| `note left/right` | [Note+]ボタン | 位置、内容編集 |
| `note over A, B` | 右クリック→追加 | 対象参加者（複数選択）、内容編集 |
| `note across` | [+追加]ボタン | 内容編集 |
| `hnote`/`rnote` | 種類変更で対応 | 形状、対象、内容編集 |

**統合編集モーダル内での表示**:
- 📝 アイコンでNoteを識別
- メッセージ/フラグメントと同列に表示
- 展開式で詳細編集（種類ドロップダウン、対象参加者選択、内容テキストエリア）

### 11.6 決定事項

| 決定 | 内容 | 反映先 |
|------|------|--------|
| TD-019 v2.0 | 3層→2層統合モーダル + 展開式インライン編集 | `technical_decisions.md` |
| TD-020 v2.0 | 3レベル→2レベル統一構造（直接操作 + 展開式編集） | `technical_decisions.md` |
| group対応 | Level 1/2で他フラグメントと同様に対応 | TD-019 v2.0 |
| Note対応 | 全Note種類をLevel 1/2で統一対応 | TD-020 v2.0 |

### 11.7 評価改善

| 項目 | Before | After | 改善 |
|------|:------:|:-----:|:----:|
| TD-019 | 65点 (D) | 85点 (B) | +20 |
| TD-020 | 75点 (C) | 85点 (B) | +10 |
| **総合** | 88.85点 (B) | **90.38点 (A)** | **+1.53** |
| **残存問題** | 2件 | **0件** | **-2** |

### 11.8 関連ドキュメント更新

| ドキュメント | 更新内容 |
|-------------|---------|
| `technical_decisions.md` | TD-019 v2.0、TD-020 v2.0追加 |
| `02_screen_composition_analysis.md` | 本ドキュメント全面更新（v3.0） |

---

## 12. TD-028 AIコード適用機能 詳細設計（Session 13 Phase 6）

> **作成日**: 2025-12-29
> **対象TD**: TD-028 AIコード適用機能
> **優先度**: MVP

### 12.1 技術的制約の明確化

#### 12.1.1 AIの技術的限界

| 能力 | 可否 | 理由 |
|------|:----:|------|
| テキストを受け取る | ✅ | LLM APIの基本機能 |
| テキストを返す | ✅ | LLM APIの基本機能 |
| Code panel（Monaco Editor）を直接操作 | ❌ | AIにはブラウザアクセス手段がない |
| ブラウザDOMを操作 | ❌ | AIはテキストイン・テキストアウトのAPI |
| Function Calling / Tool Use | ❌ | OpenRouter + 多様LLMのため使用不可 |

#### 12.1.2 システムの技術的能力

| 能力 | 可否 | 実現方法 |
|------|:----:|---------|
| AI応答からコードを抽出 | ✅ | `@startuml`〜`@enduml` パターン検出（正規表現） |
| Code panelを更新 | ✅ | Monaco Editor API (`editor.setValue()`) |
| Preview を更新 | ✅ | PlantUML レンダリング API |
| 選択要素のハイライト | ✅ | Monaco Editor Decorations API |

#### 12.1.3 重要な理解

```
「AIがCode panelを直接修正する」 = ❌ 技術的に不可能

「AIがコードを返す → システムが適用する」 = ✅ 実際の動作

ユーザー視点では「クリック一つでコードが更新される」体験が実現可能
```

---

### 12.2 確定したフロー

```
① ユーザーが対象コード（○○）を指定
   └─ GUIパネル: メッセージカードをクリック
   └─ Codeパネル: トグルボタンON → ドラッグで範囲選択

② ユーザーがAIチャットで依頼入力
   └─ 例:「loop処理にしてAとBの繰り返しでYの時に次のプロセスに移動」

③ AIがチャット欄でコード候補を回答
   └─ 自然言語の説明 + PlantUMLコードスニペット

④ ユーザーがAI回答からコード（△△）を範囲選択
   └─ トグルボタンON → ドラッグで範囲選択
   └─「コードを適用」ボタンをクリック

⑤ システムがAIに修正依頼を送信
   └─ 依頼文（後述のベストプラクティス形式）
   └─ AIが修正後の完全コードをテキストで返す

⑥ システムがAI応答を処理
   └─ @startuml〜@enduml を抽出
   └─ Monaco Editor API でCode panelを更新

⑦ 修正後コードがPreviewに自動レンダリング
   └─ ユーザーが結果を確認
   └─ 不満なら Ctrl+Z で元に戻す
```

---

### 12.3 対象コード特定機能

#### 12.3.1 GUIパネルでの選択

| # | 決定項目 | 決定内容 |
|:-:|---------|---------|
| 1 | 選択方法 | メッセージカードをクリック |
| 2 | 複数選択 | 複数回クリック（累積選択） |
| 3 | 選択クリア | クリアボタン |

#### 12.3.2 Codeパネルでの選択

| # | 決定項目 | 決定内容 |
|:-:|---------|---------|
| 4 | 選択方法 | ドラッグで範囲選択 |
| 5 | モード開始 | トグルボタン（ON/OFF切替） |
| 6 | モード中の表示 | Codeパネル枠線の色変更 |
| 7 | モード終了 | トグルボタンOFF |

#### 12.3.3 選択状態の連動

| # | 決定項目 | 決定内容 |
|:-:|---------|---------|
| 8 | GUI選択時の表示 | GUI: 選択カード表示 / Code: 黄色ハイライト / Preview: メッセージ色変更 |
| 9 | Code選択時のGUI連動 | 対応カードをハイライト |
| 10 | Code選択時のPreview連動 | 対応メッセージの色変更 |
| 11 | GUI/Code併用 | 排他（後から選択した方が有効） |
| 12 | AIへの情報伝達 | 要素テキスト + 行番号 |

---

### 12.4 AIチャットからのコード選択

#### 12.4.1 選択方法

| # | 決定項目 | 決定内容 |
|:-:|---------|---------|
| 13 | 選択モード | トグルボタンでモード切替（Codeパネルと同様） |
| 14 | 選択方法 | ドラッグでテキスト範囲選択 |
| 15 | 未選択で適用ボタン押下 | ボタン無効化（グレーアウト） |
| 16 | 部分選択（@startumlのみ等） | エラー表示「完全なコードを選択してください」 |

---

### 12.5 適用処理

#### 12.5.1 基本動作

| # | 決定項目 | 決定内容 |
|:-:|---------|---------|
| 17 | 適用ボタンの動作 | 確認ダイアログ後にAIへ送信 → 結果を適用 |
| 18 | 適用後のUndo | Ctrl+Z 1回で全復元 |
| 19 | 複数@startuml〜@enduml検出時 | 最大のブロック使用 |

#### 12.5.2 エラー処理

| # | 失敗パターン | 決定内容 |
|:-:|-------------|---------|
| 20 | コードブロックなし | AIに再生成依頼 |
| 21 | 構文エラー | AIに修正依頼（ワンボタン） |

#### 12.5.3 ワンボタンエラー修正機能

| # | 決定項目 | 決定内容 |
|:-:|---------|---------|
| 22 | ボタン表示位置 | **エラー通知バナー内**（Code/Previewパネル境界）|
| 23 | ボタンラベル | 「再生成」 |
| 24 | AIへの送信内容 | エラーメッセージ + **エラー周辺コード（必須）** + 前回試行履歴 |
| 25 | 連続エラー時 | **5回目に警告**、6回目以降は再生成ボタン非活性化 |

> **重要**: エラー通知はAIチャット欄に表示しない（会話履歴が汚れるため）

---

### 12.6 AIへの依頼文ベストプラクティス

#### 12.6.1 設計原則

| 原則 | 理由 |
|------|------|
| **構造化** | AIが各要素を明確に識別できる |
| **意図の明示** | 元の依頼を含め、機械的置換ではなく意図に基づく修正を促す |
| **出力制約** | 抽出しやすい形式を強制 |
| **エッジケース対応** | 未選択・複数選択にも対応 |

#### 12.6.2 推奨フォーマット

```
【コード修正実行】

■ ユーザーの依頼
「${originalUserRequest}」

■ 修正対象
${○○.text}（${○○.lineNumber}行目）

■ 適用コード
${△△}

■ 指示
上記の依頼意図に基づき、修正対象を適用コードで修正してください。

■ 出力形式
修正後の完全なPlantUMLコード（@startuml〜@enduml）のみ。
説明文は不要です。
```

#### 12.6.3 各要素の役割

| 要素 | 役割 | 例 |
|------|------|-----|
| **ユーザーの依頼** | 修正の意図・目的を明確化 | 「loop処理にしてAとBの繰り返しに」 |
| **修正対象（○○）** | どこを修正するか特定 | `Alice -> Bob: Hello`（5行目） |
| **適用コード（△△）** | 何を適用するか明示 | `loop ... end` |
| **指示** | 実行内容の明確化 | 意図に基づく修正 |
| **出力形式** | 抽出可能な形式を強制 | コードのみ、説明不要 |

#### 12.6.4 なぜ「元の依頼」が重要か

| シナリオ | △△の内容 | 必要な処理 |
|---------|----------|-----------|
| 単純置換 | `participant UserA` | ○○をそのまま置換 |
| 構造追加 | `loop ... end` | ○○を**内包**してloopで囲む |
| 複雑変更 | 部分的なコード片 | 意図を理解して統合 |

**「元の依頼」がないと、AIは機械的置換しかできない。**
**「元の依頼」があれば、AIは意図を理解して適切に統合できる。**

#### 12.6.5 エッジケース対応

| ケース | 修正対象の記載 |
|--------|---------------|
| **○○未選択** | `修正対象: 未指定（依頼内容に基づきAIが判断）` |
| **○○複数選択** | `修正対象:`<br>`1. Alice -> Bob: Hello（5行目）`<br>`2. Bob -> Alice: Hi（6行目）` |
| **△△が完全コード** | そのまま送信（AIが認識して返す） |

#### 12.6.6 実装コード例

```typescript
interface SelectedElement {
  text: string;
  lineNumber: number;
}

function buildApplyPrompt(
  originalRequest: string,
  target: SelectedElement | SelectedElement[] | null,
  appliedCode: string
): string {
  // 修正対象のフォーマット
  let targetText: string;
  if (target === null) {
    targetText = '未指定（依頼内容に基づきAIが判断）';
  } else if (Array.isArray(target)) {
    targetText = target
      .map((t, i) => `${i + 1}. ${t.text}（${t.lineNumber}行目）`)
      .join('\n');
  } else {
    targetText = `${target.text}（${target.lineNumber}行目）`;
  }

  return `【コード修正実行】

■ ユーザーの依頼
「${originalRequest}」

■ 修正対象
${targetText}

■ 適用コード
${appliedCode}

■ 指示
上記の依頼意図に基づき、修正対象を適用コードで修正してください。

■ 出力形式
修正後の完全なPlantUMLコード（@startuml〜@enduml）のみ。
説明文は不要です。`;
}
```

---

### 12.7 システム処理フロー

#### 12.7.1 「適用」ボタンクリック時の処理

```typescript
async function handleApplyCode(
  originalRequest: string,
  selectedTarget: SelectedElement | null,
  selectedCode: string,
  currentCode: string
): Promise<void> {
  // 1. バリデーション
  if (!selectedCode.trim()) {
    showError('コードを選択してください');
    return;
  }

  // 2. 確認ダイアログ
  const confirmed = await showConfirmDialog('選択したコードを適用しますか？');
  if (!confirmed) return;

  // 3. AIに修正依頼を送信
  const prompt = buildApplyPrompt(originalRequest, selectedTarget, selectedCode);
  const aiResponse = await sendToAI(prompt);

  // 4. AI応答からコードを抽出
  const extractedCode = extractPlantUMLCode(aiResponse);
  if (!extractedCode) {
    showError('AIからの応答に有効なPlantUMLコードが含まれていません');
    // 再生成ボタンを表示
    showRegenerateButton();
    return;
  }

  // 5. Undo用に現在の状態を保存
  saveUndoState(currentCode);

  // 6. Code panelを更新
  monacoEditor.setValue(extractedCode);

  // 7. 成功メッセージ
  showSuccess('コードを適用しました');
}

function extractPlantUMLCode(response: string): string | null {
  // @startuml〜@enduml を抽出
  const regex = /@startuml[\s\S]*?@enduml/g;
  const matches = response.match(regex);

  if (!matches || matches.length === 0) {
    return null;
  }

  // 複数ブロックがある場合は最大のものを返す
  return matches.reduce((largest, current) =>
    current.length > largest.length ? current : largest
  );
}
```

#### 12.7.2 エラー時の再生成処理

> **詳細仕様**: セクション12.12「エラー修正機能 詳細設計」参照

**簡易概要**:
```typescript
// 詳細実装は12.12.9参照
// エラー周辺コード（± 5行）+ 試行履歴 を含むプロンプトを送信
// AI応答から自動抽出 → Monaco Editor setValue() で自動適用
// 5回目に警告、6回目以降は再生成ボタン非活性化
```

---

### 12.8 議論の経緯

#### 12.8.1 初期提案と問題点

**初期提案（却下）**: AIチャット内の各コードブロックに「適用」ボタンを配置

**問題点**:
- AI回答は自然言語であり、構造化されていない
- 各回答にボタンを配置するのは非現実的
- どのコードブロックが「最終提案」か判別困難

#### 12.8.2 代替案の検討

| 案 | 内容 | 評価 |
|:--:|------|:----:|
| A | 最新コードのみ適用 | △ 最新が希望でない可能性 |
| B | コードブロック抽出表示 | × カスタム開発が必要 |
| C | Undo履歴で対応 | × 複数候補の比較不可 |
| **D** | **ユーザーによる範囲選択** | **✅ 採用** |

#### 12.8.3 「AIが直接修正」の議論

**ユーザーからの質問**: 「AIがCode panelを直接修正できないの？」

**技術的回答**:
- AI（LLM）はテキストイン・テキストアウトのAPI
- AIにはブラウザやMonaco Editorへのアクセス手段がない
- Function Calling / Tool UseもOpenRouter制約で使用不可

**解決策**:
- 「AI直接修正」はユーザー視点の抽象化
- 実際は「AIがコードを返す → システムが適用する」
- ユーザー体験としては「クリック一つでコードが更新」が実現可能

#### 12.8.4 依頼文の重要性

**初期の依頼文（問題あり）**:
```
○○を△△で修正せよ
```

**問題点**:
- 機械的置換のみで、意図が伝わらない
- 構造追加（loopで囲む等）に対応できない

**改善後の依頼文**:
```
【コード修正実行】
■ ユーザーの依頼「${originalRequest}」
■ 修正対象 ...
■ 適用コード ...
■ 指示 上記の依頼意図に基づき...
```

**改善点**:
- 「元の依頼」を含めることで意図が明確に
- 構造化により各要素の役割が明確
- 出力形式の制約で抽出しやすく

---

### 12.9 決定事項サマリー

| カテゴリ | 決定項目 | 決定内容 |
|---------|---------|---------|
| **技術制約** | AI直接修正 | 不可能（システム経由で適用） |
| **対象選択（GUI）** | 選択方法 | メッセージカードクリック、累積選択 |
| **対象選択（Code）** | 選択方法 | トグルボタン → ドラッグ選択 |
| **選択連動** | 3パネル連動 | GUI/Code/Preview すべてでハイライト |
| **AI回答選択** | 選択方法 | トグルボタン → ドラッグ選択 |
| **適用処理** | 適用方式 | 確認ダイアログ → AI送信 → 結果適用 |
| **適用処理** | Undo | Ctrl+Z 1回で全復元 |
| **エラー処理** | 構文エラー | AIに修正依頼（ワンボタン）→ 詳細は12.12参照 |
| **エラー処理** | 通知場所 | **Previewパネル上部バナー**（AIチャット欄は不使用）|
| **エラー処理** | 回数制限 | **5回目に警告**、6回目以降は非活性化 |
| **依頼文** | フォーマット | 構造化形式（元依頼 + 対象 + 適用コード + 指示） |

---

### 12.10 関連TD

| TD | タイトル | 関連内容 |
|:--:|---------|---------|
| TD-017 | GUIパネル動的切り替え | GUI要素選択の基盤 |
| TD-018 | パネル間同期 | 選択状態の3パネル連動 |
| TD-024 | Undo/Redo | 適用後のUndo機能 |
| TD-028 | AIコード適用 | 本セクションの主題 |

---

### 12.11 更新履歴

| 日時 | 内容 |
|------|------|
| 2025-12-29 | Section 12 新規作成（Session 13 Phase 6: TD-028詳細設計） |
| 2025-12-29 | Section 12.12 追加（エラー修正機能 詳細設計）|
| 2025-12-29 | Section 12.13 追加（階層的憲法システム）|

---

### 12.12 エラー修正機能 詳細設計（Session 13 Phase 7）

> **作成日**: 2025-12-29
> **対象**: AIコード適用時の構文エラー処理

#### 12.12.1 エラー発生時の画面状態

**画面構成（エラー発生後）**:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ ヘッダー                                    [GUI+Code] [GUI] [Code]         │
├────────┬─────────────┬──────────────────────────────────────────────────────┤
│ GUI    │ Code        │ Preview                                              │
│ Panel  │ Panel       │ Panel                                                │
│        │             │                                                      │
│        │  12│ ★黄色  │  ┌──────────────────────────────────────────────┐   │
│        │  ハイライト │  │ ⚠️ 構文エラー（12行目）                     │   │
│        │             │  │ Expected 'as' keyword                       │   │
│        │             │  │            [再生成] [閉じる]                 │   │
│        │             │  └──────────────────────────────────────────────┘   │
│        │             │                                                      │
├────────┴─────────────┴──────────────────────────────────────────────────────┤
│ AIチャットパネル（エラー通知なし = クリーンな会話履歴維持）                  │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 12.12.2 エラー通知方式

| 要素 | 実装 | 理由 |
|------|------|------|
| **Monaco Editor ハイライト** | 黄色背景（TD-017準拠）| エラー箇所を視覚的に明示 |
| **インラインバナー** | Preview上部に表示 | ワークフロー中断を避ける |
| **AIチャット欄** | **使用しない** | 会話履歴の汚染を防止 |
| **モーダル** | **使用しない** | 作業フローの中断を防止 |

#### 12.12.3 エラー通知バナー仕様

| 項目 | 仕様 |
|------|------|
| **表示位置** | Previewパネル上端（Code/Preview境界付近）|
| **背景色** | オレンジ系警告色（#FFF3CD または類似）|
| **テキスト色** | 濃いオレンジ/茶色（#856404）|
| **アイコン** | ⚠️ 警告アイコン |
| **内容** | エラー種別（行番号）+ エラーメッセージ |
| **ボタン** | 「再生成」「閉じる」|
| **自動消去** | なし（ユーザー操作まで表示継続）|
| **サイズ** | 高さ約60px、幅はPreviewパネル幅に追従 |

**バナーHTML構造例**:
```html
<div class="error-banner">
  <span class="error-icon">⚠️</span>
  <div class="error-content">
    <span class="error-title">構文エラー（12行目）</span>
    <span class="error-message">Expected 'as' keyword</span>
  </div>
  <div class="error-actions">
    <button class="btn-regenerate">再生成</button>
    <button class="btn-close">閉じる</button>
  </div>
</div>
```

#### 12.12.4 AIへの送信内容（エラー修正依頼）

| 項目 | 内容 | 必須 |
|------|------|:----:|
| **元の依頼** | ユーザーの最初の修正依頼 | ✅ |
| **エラーメッセージ** | PlantUMLバリデーションエラー | ✅ |
| **エラー行番号** | 構文エラーの発生行 | ✅ |
| **エラー周辺コード** | エラー行 ± 5行（計11行）| ✅ |
| **完全コード** | @startuml〜@enduml全体 | ✅ |
| **前回試行履歴** | 過去の修正試行とエラー内容 | ✅ |

**なぜエラー周辺コードが必要か**:
- AIの会話履歴はコンテキストウィンドウの制限で失われる可能性
- 周辺コンテキストがあると、AIがエラー原因をより正確に特定できる
- 特に長いPlantUMLコードの場合、エラー箇所のみでは文脈不足

#### 12.12.5 自動適用の技術的仕組み

**「自動適用」とは**:
エラー再生成後、ユーザーが範囲選択や「適用」ボタンを押さずとも、
システムがAI応答からコードを抽出し自動でCode panelに反映する仕組み。

**技術的には通常適用と同一**:

```
【通常適用フロー】
ユーザー → AI回答から範囲選択 → 「適用」クリック
  → システムがAIに修正依頼送信
  → AI応答受信
  → @startuml〜@enduml抽出（正規表現）
  → Monaco Editor setValue()
  → 構文検証 → エラーあり → エラー処理へ

【エラー再生成フロー（自動適用）】
ユーザー → 「再生成」クリック
  → システムがAIにエラー修正依頼送信
  → AI応答受信
  → @startuml〜@enduml抽出（正規表現）★
  → Monaco Editor setValue()           ★ ← 自動適用（ユーザー操作不要）
  → 構文検証
    → エラーなし → 完了、バナー消去
    → エラーあり → エラー処理ループ（試行回数+1）
```

**「自動」の意味**:
- 通常適用：ユーザーがAI回答からコード範囲選択 → 「適用」クリック必要
- エラー再生成：**ユーザー操作不要**、システムが自動でコード抽出・適用

#### 12.12.6 回数制限と警告

| 試行回数 | システム動作 |
|:--------:|-------------|
| 1〜4回目 | 通常のエラー再生成処理（バナー表示 → 再生成 → 自動適用）|
| **5回目** | **警告メッセージ表示** + 再生成ボタン有効 + 手動修正推奨メッセージ |
| 6回目以降 | 再生成ボタン**非活性化**、手動修正のみ可能 |

**5回目警告時のバナー**:
```
┌──────────────────────────────────────────────────────────────────────────┐
│ ⚠️ エラー修正の試行回数が上限に達しました（5/5）                         │
│ AIによる自動修正が困難なエラーの可能性があります。                       │
│ 手動でコードを修正することをお勧めします。                               │
│                                    [最後の再生成] [閉じる]               │
└──────────────────────────────────────────────────────────────────────────┘
```

**6回目以降のバナー**:
```
┌──────────────────────────────────────────────────────────────────────────┐
│ ❌ 自動修正の上限（5回）を超えました                                     │
│ 手動でコードを修正してください。                                         │
│                                                      [閉じる]            │
└──────────────────────────────────────────────────────────────────────────┘
```

#### 12.12.7 エラー修正依頼プロンプト

```typescript
interface ErrorFixRequest {
  originalRequest: string;     // 元のユーザー依頼
  errorMessage: string;        // エラーメッセージ
  errorLineNumber: number;     // エラー行番号
  surroundingCode: string;     // エラー行 ± 5行
  fullCode: string;            // 完全な@startuml〜@enduml
  attemptHistory: AttemptRecord[]; // 過去の試行履歴
}

interface AttemptRecord {
  attemptNumber: number;
  errorMessage: string;
  appliedFix: string;  // 試行した修正内容（概要）
}

function buildErrorFixPrompt(request: ErrorFixRequest): string {
  // 試行履歴のフォーマット
  let historyText = '';
  if (request.attemptHistory.length > 0) {
    historyText = '\n■ 過去の修正試行\n';
    historyText += request.attemptHistory
      .map(a => `  ${a.attemptNumber}回目: ${a.errorMessage}`)
      .join('\n');
    historyText += '\n';
  }

  return `【エラー修正依頼】

■ 元の依頼
「${request.originalRequest}」

■ 発生したエラー
${request.errorMessage}
（${request.errorLineNumber}行目）

■ エラー周辺のコード
\`\`\`plantuml
${request.surroundingCode}
\`\`\`
${historyText}
■ 完全なコード
\`\`\`plantuml
${request.fullCode}
\`\`\`

■ 指示
上記のエラーを修正した完全なPlantUMLコード（@startuml〜@enduml）のみを返してください。
説明文は不要です。`;
}
```

#### 12.12.8 周辺コード抽出関数

```typescript
function extractSurroundingCode(
  fullCode: string,
  errorLine: number,
  contextLines: number = 5
): string {
  const lines = fullCode.split('\n');
  const startLine = Math.max(0, errorLine - contextLines - 1);
  const endLine = Math.min(lines.length, errorLine + contextLines);

  return lines
    .slice(startLine, endLine)
    .map((line, idx) => {
      const lineNum = startLine + idx + 1;
      const marker = lineNum === errorLine ? '>>> ' : '    ';
      return `${marker}${lineNum}| ${line}`;
    })
    .join('\n');
}

// 使用例:
// エラー行: 12
// 出力:
//      7| participant Alice
//      8| participant Bob
//      9|
//     10| Alice -> Bob: Hello
//     11| activate Bob
// >>> 12| Bob -> Alice
//     13| deactivate Bob
//     14|
//     15| @enduml
```

#### 12.12.9 エラー処理フロー（完全版）

```typescript
let attemptCount = 0;
const MAX_ATTEMPTS = 5;
const attemptHistory: AttemptRecord[] = [];

async function handleSyntaxError(
  originalRequest: string,
  errorMessage: string,
  errorLine: number,
  fullCode: string
): Promise<void> {
  attemptCount++;

  // 1. 上限チェック
  if (attemptCount > MAX_ATTEMPTS) {
    showFinalErrorBanner();
    return;
  }

  // 2. 5回目警告チェック
  if (attemptCount === MAX_ATTEMPTS) {
    showWarningBanner();
    // ボタンは有効のまま継続
  }

  // 3. バナー表示
  showErrorBanner({
    message: errorMessage,
    line: errorLine,
    attemptCount: attemptCount,
    maxAttempts: MAX_ATTEMPTS,
    onRegenerate: async () => {
      // 4. 周辺コード抽出
      const surroundingCode = extractSurroundingCode(fullCode, errorLine);

      // 5. プロンプト構築
      const prompt = buildErrorFixPrompt({
        originalRequest,
        errorMessage,
        errorLineNumber: errorLine,
        surroundingCode,
        fullCode,
        attemptHistory
      });

      // 6. AIに送信
      const aiResponse = await sendToAI(prompt);

      // 7. コード抽出
      const fixedCode = extractPlantUMLCode(aiResponse);
      if (!fixedCode) {
        showErrorBanner({ message: 'AIから有効なコードが返されませんでした', ... });
        return;
      }

      // 8. 試行履歴に記録
      attemptHistory.push({
        attemptNumber: attemptCount,
        errorMessage: errorMessage,
        appliedFix: `AI修正適用（${new Date().toLocaleTimeString()}）`
      });

      // 9. 自動適用（Monaco Editor更新）
      monacoEditor.setValue(fixedCode);

      // 10. 再検証
      const validationResult = await validatePlantUML(fixedCode);
      if (validationResult.isValid) {
        // 成功 → バナー消去、カウンターリセット
        hideErrorBanner();
        attemptCount = 0;
        attemptHistory.length = 0;
        showSuccess('エラーが修正されました');
      } else {
        // 再度エラー → 再帰的に処理
        await handleSyntaxError(
          originalRequest,
          validationResult.errorMessage,
          validationResult.errorLine,
          fixedCode
        );
      }
    },
    onClose: () => {
      hideErrorBanner();
      // カウンターはリセットしない（ユーザーが手動修正する可能性）
    }
  });
}
```

#### 12.12.10 決定事項サマリー

| カテゴリ | 項目 | 決定内容 |
|---------|------|---------|
| **通知方式** | エラー表示 | Previewパネル上部のインラインバナー |
| **通知方式** | AIチャット | **使用しない**（会話履歴汚染防止）|
| **通知方式** | モーダル | **使用しない**（フロー中断防止）|
| **通知方式** | Monaco | 黄色背景ハイライト（TD-017準拠）|
| **送信内容** | エラー周辺コード | **必須**（± 5行 = 計11行）|
| **送信内容** | 試行履歴 | **必須**（AIが同じ修正を繰り返さないため）|
| **適用方式** | 自動適用 | AI応答から自動抽出・自動setValue()（通常適用と同一技術）|
| **回数制限** | 警告 | **5回目**に警告メッセージ |
| **回数制限** | 上限 | 6回目以降は再生成ボタン非活性化 |

---

### 12.13 階層的憲法システム（Session 13 Phase 8）

> **作成日**: 2025-12-29
> **対象**: AIへのプロンプト生成アーキテクチャ
> **目的**: LLM・図表タイプごとに最適化された依頼文を動的に生成

#### 12.13.1 問題提起

**現状の問題（ハードコードされたプロンプト）**:

| 問題 | 影響 |
|------|------|
| LLMごとに生成品質が異なる | Claude/GPT/Gemini/Llamaで出力傾向が違う |
| PlantUML構文エラーが頻発 | 図表タイプごとに既知の制限がある |
| プロンプト修正 = コード修正 | デプロイが必要、改善サイクルが遅い |
| A/Bテストが困難 | プロンプト効果測定ができない |
| 組み合わせ爆発 | 5 LLM × 10 図表 = 50パターンの個別対応が困難 |

**根本原因**:
- AIへの依頼文がソースコードにハードコードされている
- LLMの「癖」や図表の「既知制限」が体系化されていない
- 運用で得た知見をプロンプトに反映する仕組みがない

#### 12.13.2 解決策：階層的憲法システム

**コンセプト**:
- **憲法（Constitution）**: AIが守るべきルール・制約を外部ファイルで定義
- **階層構造**: 共通→LLM固有→図表固有→組み合わせ固有の4層で継承
- **動的マージ**: 実行時に適切な憲法を組み合わせてプロンプトを生成
- **即時反映**: YAMLファイル更新のみでデプロイ不要

**アーキテクチャ概要**:

```
┌─────────────────────────────────────────────────────────────────┐
│                    階層的憲法システム                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Layer 1: 基底憲法（Base Constitution）                   │   │
│  │ ・全LLM・全図表共通ルール                                │   │
│  │ ・@startuml必須、出力形式、基本禁止事項                  │   │
│  └────────────────────────┬────────────────────────────────┘   │
│                           │                                     │
│           ┌───────────────┴───────────────┐                     │
│           ▼                               ▼                     │
│  ┌─────────────────┐             ┌─────────────────┐           │
│  │ Layer 2: LLM層  │             │ Layer 3: 図表層 │           │
│  │ ・claude.yaml   │             │ ・sequence.yaml │           │
│  │ ・gpt4.yaml     │             │ ・class.yaml    │           │
│  │ ・gemini.yaml   │             │ ・activity.yaml │           │
│  │ ・llama.yaml    │             │ ・usecase.yaml  │           │
│  └────────┬────────┘             └────────┬────────┘           │
│           │                               │                     │
│           └───────────────┬───────────────┘                     │
│                           ▼                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Layer 4: 組み合わせ層（Combined）                        │   │
│  │ ・claude_activity.yaml（特定組み合わせの問題対応）       │   │
│  │ ・gpt4_sequence.yaml                                     │   │
│  │ ・必要な場合のみ作成（全組み合わせは不要）               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 12.13.3 ディレクトリ構成

```
src/
├── ai/
│   ├── prompt/
│   │   ├── IPromptBuilder.ts           # プロンプトビルダーIF
│   │   ├── PromptBuilderFactory.ts     # ファクトリ
│   │   ├── builders/
│   │   │   ├── ApplyPromptBuilder.ts   # コード適用用
│   │   │   ├── ErrorFixPromptBuilder.ts # エラー修正用
│   │   │   └── GeneratePromptBuilder.ts # 新規生成用
│   │   └── templates/
│   │       ├── apply.template.ts
│   │       ├── error_fix.template.ts
│   │       └── generate.template.ts
│   │
│   ├── constitution/
│   │   ├── IConstitutionProvider.ts    # 憲法プロバイダーIF
│   │   ├── IConstitutionResolver.ts    # 憲法解決IF
│   │   ├── HierarchicalResolver.ts     # 階層的解決実装
│   │   ├── providers/
│   │   │   ├── FileConstitutionProvider.ts    # ファイルベース
│   │   │   └── SupabaseConstitutionProvider.ts # DB版（v1.1）
│   │   └── schemas/
│   │       ├── base.yaml               # 基底憲法
│   │       ├── llm/
│   │       │   ├── claude.yaml
│   │       │   ├── gpt4.yaml
│   │       │   ├── gemini.yaml
│   │       │   └── llama.yaml
│   │       ├── diagram/
│   │       │   ├── sequence.yaml
│   │       │   ├── class.yaml
│   │       │   ├── activity.yaml
│   │       │   ├── usecase.yaml
│   │       │   ├── state.yaml
│   │       │   └── component.yaml
│   │       └── combined/
│   │           ├── claude_activity.yaml
│   │           └── gpt4_sequence.yaml
│   │
│   └── AIService.ts                    # 依存性注入で統合
```

#### 12.13.4 各層の責務

| 層 | ファイル | 責務 | 内容例 |
|:--:|---------|------|--------|
| **Layer 1** | `base.yaml` | 全共通ルール | @startuml必須、単一ブロック出力、説明文禁止 |
| **Layer 2** | `llm/*.yaml` | LLMの癖対応 | Claude:説明抑制、GPT:冗長防止、Gemini:特定構文回避 |
| **Layer 3** | `diagram/*.yaml` | 図表固有構文 | Activity:if内遷移禁止、Sequence:activate対応 |
| **Layer 4** | `combined/*.yaml` | 特定問題対応 | Claude+Activity:partition内if回避 |

**ファイル数の現実**:
- Layer 1: 1ファイル
- Layer 2: 4〜5ファイル（主要LLM）
- Layer 3: 6〜10ファイル（主要図表）
- Layer 4: 必要時のみ（0〜10ファイル）

**合計: 約15〜25ファイル**（50パターンではなく）

#### 12.13.5 憲法ファイル仕様

**共通スキーマ**:

```typescript
interface Constitution {
  version: string;
  type: 'base' | 'llm' | 'diagram' | 'combined';
  extends?: string | string[];
  target?: string;                    // LLM名 or 図表名
  target_llm?: string;                // combined用
  target_diagram?: string;            // combined用

  // ルール定義
  requirements?: string[];            // 必須ルール
  prohibitions?: string[];            // 禁止事項
  recommendations?: string[];         // 推奨事項

  // 追加ルール（継承時）
  additional_requirements?: string[];
  additional_prohibitions?: string[];
  additional_recommendations?: string[];

  // 出力形式
  output_format?: {
    wrapper?: string;                 // コードラッパー
    single_block?: boolean;           // 単一ブロック強制
    no_explanation?: boolean;         // 説明文禁止
    max_lines?: number;               // 最大行数
  };

  // 既知の問題（運用知見）
  known_issues?: {
    id: string;
    description: string;
    workaround: string;
  }[];

  // メタ情報
  notes?: string[];
  updated_at?: string;
  updated_by?: string;
}
```

#### 12.13.6 憲法ファイル実例

**base.yaml（Layer 1: 基底憲法）**:

```yaml
version: "1.0.0"
type: "base"
updated_at: "2025-12-29"

# 全LLM・全図表に適用される基本ルール
requirements:
  - "必ず @startuml で開始し @enduml で終了する"
  - "コードブロックは1つのみ出力する"
  - "説明文や前置きは出力しない、コードのみ"
  - "指示された出力形式を厳守する"

prohibitions:
  - "複数の @startuml〜@enduml ブロックを出力しない"
  - "「以下のコードを...」等の前置きを出力しない"
  - "コード後の解説や補足を出力しない"
  - "未完成のコード（...や省略記号）を出力しない"

recommendations:
  - "シンプルで読みやすい構造を心がける"
  - "不要な装飾（skinparam過多）を避ける"

output_format:
  single_block: true
  no_explanation: true

notes:
  - "この憲法は全てのLLM・図表に継承される"
  - "Layer 2-4 で上書き・追加可能"
```

**llm/claude.yaml（Layer 2: Claude固有）**:

```yaml
version: "1.0.0"
type: "llm"
target: "claude"
extends: "base"
updated_at: "2025-12-29"

# Claudeの傾向: 丁寧に説明しがち、長文になりがち
additional_prohibitions:
  - "コード生成前に「承知しました」「以下に...」等を出力しない"
  - "コード生成後に「このコードは...」「上記のコードでは...」等を出力しない"
  - "改善提案や代替案を求められていない限り提示しない"

additional_requirements:
  - "指示された内容のみを出力する"
  - "簡潔さを最優先する"

notes:
  - "Claudeは非常に丁寧だが、コード生成時は簡潔さが重要"
  - "説明を求められた場合のみ説明を追加する"
```

**llm/gpt4.yaml（Layer 2: GPT-4固有）**:

```yaml
version: "1.0.0"
type: "llm"
target: "gpt4"
extends: "base"
updated_at: "2025-12-29"

# GPT-4の傾向: 創造的だが時に冗長、コメント過多
additional_prohibitions:
  - "コード内に過度なコメントを入れない"
  - "代替案を複数提示しない（1つのベスト案のみ）"
  - "PlantUMLのskinparamを過度に使用しない"

additional_requirements:
  - "最もシンプルな実装を選択する"
  - "コメントは本当に必要な場合のみ"

notes:
  - "GPT-4は創造的だが、シンプルさを明示的に指示する必要がある"
```

**diagram/sequence.yaml（Layer 3: シーケンス図固有）**:

```yaml
version: "1.0.0"
type: "diagram"
target: "sequence"
extends: "base"
updated_at: "2025-12-29"

additional_requirements:
  - "participant宣言は使用順に先頭で行う"
  - "activate/deactivateは必ずペアで使用する"
  - "長いメッセージはnoteで補足する"

additional_prohibitions:
  - "note bottom of 構文を使用しない（note over を使用）"
  - "activate後にdeactivateなしで終了しない"
  - "未宣言のparticipantを使用しない"

additional_recommendations:
  - "複雑なフローはalt/opt/loopで構造化する"
  - "参加者が多い場合はbox groupingを検討する"

known_issues:
  - id: "SEQ-001"
    description: "note bottom of がレンダリングエラーになる"
    workaround: "note over を使用する"
  - id: "SEQ-002"
    description: "activateの入れ子が深いとレイアウト崩れ"
    workaround: "入れ子は最大3レベルまで"
```

**diagram/activity.yaml（Layer 3: アクティビティ図固有）**:

```yaml
version: "1.0.0"
type: "diagram"
target: "activity"
extends: "base"
updated_at: "2025-12-29"

additional_requirements:
  - "endif後に1行アクションを入れてからスイムレーン遷移する"
  - "複雑な分岐はnoteで説明を補足する"
  - "開始点(@startuml直後)と終了点(stop/end)を明確にする"

additional_prohibitions:
  - "if/elseif/else 内でスイムレーン（|lane|）遷移しない"
  - "fork/join 内でスイムレーン遷移しない"
  - "switch/case 内でスイムレーン遷移しない"
  - "while内でスイムレーン遷移しない"

known_issues:
  - id: "ACT-001"
    description: "if内スイムレーン遷移でレンダリングエラー"
    workaround: "if全体を1スイムレーン内に収め、noteで詳細を説明"
  - id: "ACT-002"
    description: "fork内スイムレーン遷移でレンダリングエラー"
    workaround: "fork全体を1スイムレーン内に収める"
  - id: "ACT-003"
    description: "endif直後のスイムレーン遷移でエラー"
    workaround: "endif後に1行アクション（例: :処理完了;）を入れてから遷移"

notes:
  - "アクティビティ図はPlantUMLの既知制限が多い"
  - "スイムレーン使用時は特に注意が必要"
```

**combined/claude_activity.yaml（Layer 4: Claude×Activity固有）**:

```yaml
version: "1.0.0"
type: "combined"
target_llm: "claude"
target_diagram: "activity"
extends:
  - "llm/claude"
  - "diagram/activity"
updated_at: "2025-12-29"

# Claude + Activity 特有の問題
additional_prohibitions:
  - "partition内でのif文使用を避ける"
  - "複雑なネスト構造（3レベル以上）を避ける"

additional_requirements:
  - "シンプルなフロー構造を優先する"
  - "複雑な条件は分割して表現する"

notes:
  - "Claudeはactivity図で複雑な構造を生成しがち"
  - "明示的にシンプルさを指示する必要あり"
  - "partition + if の組み合わせでエラー頻発"
```

#### 12.13.7 インターフェース定義

```typescript
// ========================================
// IConstitutionProvider.ts
// 憲法ファイルの読み込みを抽象化
// ========================================

interface IConstitutionProvider {
  /**
   * 指定パスの憲法を読み込む
   * @param path 相対パス（例: "base", "llm/claude", "diagram/sequence"）
   * @returns 憲法オブジェクト、存在しない場合はnull
   */
  load(path: string): Promise<Constitution | null>;

  /**
   * 利用可能な全憲法のリストを取得
   */
  list(): Promise<string[]>;

  /**
   * 憲法のバージョンを取得
   */
  getVersion(path: string): Promise<string | null>;
}

// ========================================
// IConstitutionResolver.ts
// 階層的な憲法解決を抽象化
// ========================================

interface IConstitutionResolver {
  /**
   * LLMと図表タイプから適切な憲法を解決・マージ
   * @param llm LLMタイプ
   * @param diagramType 図表タイプ
   * @returns マージ済み憲法
   */
  resolve(llm: LLMType, diagramType: DiagramType): Promise<ResolvedConstitution>;
}

interface ResolvedConstitution {
  // マージ後のルール
  requirements: string[];
  prohibitions: string[];
  recommendations: string[];
  outputFormat: OutputFormat;
  knownIssues: KnownIssue[];

  // メタ情報
  resolvedFrom: string[];    // マージ元ファイル一覧
  resolvedAt: Date;
}

// ========================================
// IPromptBuilder.ts
// プロンプト構築を抽象化
// ========================================

interface IPromptBuilder {
  /**
   * コンテキストからプロンプトを構築
   * @param context プロンプトコンテキスト
   * @returns 構築されたプロンプト文字列
   */
  build(context: PromptContext): Promise<string>;
}

interface PromptContext {
  type: 'apply' | 'error_fix' | 'generate';
  llm: LLMType;
  diagramType: DiagramType;
  userRequest: string;
  currentCode?: string;
  targetElements?: SelectedElement[];
  appliedCode?: string;
  errorInfo?: ErrorInfo;
  attemptHistory?: AttemptRecord[];
}

type LLMType = 'claude' | 'gpt4' | 'gemini' | 'llama' | 'mistral';
type DiagramType = 'sequence' | 'class' | 'activity' | 'usecase' | 'state' | 'component';
```

#### 12.13.8 階層的解決実装

```typescript
// HierarchicalConstitutionResolver.ts

class HierarchicalConstitutionResolver implements IConstitutionResolver {
  constructor(private provider: IConstitutionProvider) {}

  async resolve(llm: LLMType, diagramType: DiagramType): Promise<ResolvedConstitution> {
    // 1. 各層の憲法を読み込み（存在しない場合はnull）
    const base = await this.provider.load('base');
    const llmSpecific = await this.provider.load(`llm/${llm}`);
    const diagramSpecific = await this.provider.load(`diagram/${diagramType}`);
    const combined = await this.provider.load(`combined/${llm}_${diagramType}`);

    // 2. 読み込み結果をログ
    const resolvedFrom: string[] = [];
    if (base) resolvedFrom.push('base');
    if (llmSpecific) resolvedFrom.push(`llm/${llm}`);
    if (diagramSpecific) resolvedFrom.push(`diagram/${diagramType}`);
    if (combined) resolvedFrom.push(`combined/${llm}_${diagramType}`);

    // 3. 優先度順にマージ（後勝ち）
    const merged = this.merge([base, llmSpecific, diagramSpecific, combined]);

    return {
      ...merged,
      resolvedFrom,
      resolvedAt: new Date()
    };
  }

  private merge(constitutions: (Constitution | null)[]): Omit<ResolvedConstitution, 'resolvedFrom' | 'resolvedAt'> {
    const result = {
      requirements: [] as string[],
      prohibitions: [] as string[],
      recommendations: [] as string[],
      outputFormat: {} as OutputFormat,
      knownIssues: [] as KnownIssue[]
    };

    for (const c of constitutions) {
      if (!c) continue;

      // 配列は結合
      if (c.requirements) result.requirements.push(...c.requirements);
      if (c.additional_requirements) result.requirements.push(...c.additional_requirements);

      if (c.prohibitions) result.prohibitions.push(...c.prohibitions);
      if (c.additional_prohibitions) result.prohibitions.push(...c.additional_prohibitions);

      if (c.recommendations) result.recommendations.push(...c.recommendations);
      if (c.additional_recommendations) result.recommendations.push(...c.additional_recommendations);

      if (c.known_issues) result.knownIssues.push(...c.known_issues);

      // オブジェクトは上書きマージ
      if (c.output_format) {
        result.outputFormat = { ...result.outputFormat, ...c.output_format };
      }
    }

    // 重複排除
    result.requirements = [...new Set(result.requirements)];
    result.prohibitions = [...new Set(result.prohibitions)];
    result.recommendations = [...new Set(result.recommendations)];

    return result;
  }
}
```

#### 12.13.9 プロンプトビルダー実装

```typescript
// ApplyPromptBuilder.ts

class ApplyPromptBuilder implements IPromptBuilder {
  constructor(
    private resolver: IConstitutionResolver,
    private templateEngine: ITemplateEngine
  ) {}

  async build(context: PromptContext): Promise<string> {
    // 1. 憲法を解決
    const constitution = await this.resolver.resolve(context.llm, context.diagramType);

    // 2. テンプレート変数を準備
    const variables = {
      userRequest: context.userRequest,
      targetElements: this.formatTargetElements(context.targetElements),
      appliedCode: context.appliedCode,
      currentCode: context.currentCode,

      // 憲法から動的に生成
      constitutionRules: this.formatConstitutionRules(constitution)
    };

    // 3. テンプレートを適用
    return this.templateEngine.render('apply', variables);
  }

  private formatConstitutionRules(constitution: ResolvedConstitution): string {
    const sections: string[] = [];

    // 禁止事項
    if (constitution.prohibitions.length > 0) {
      sections.push('【禁止事項】');
      constitution.prohibitions.forEach(p => {
        sections.push(`- ${p}`);
      });
    }

    // 必須ルール
    if (constitution.requirements.length > 0) {
      sections.push('');
      sections.push('【必須ルール】');
      constitution.requirements.forEach(r => {
        sections.push(`- ${r}`);
      });
    }

    // 既知の問題（該当する場合）
    if (constitution.knownIssues.length > 0) {
      sections.push('');
      sections.push('【既知の制限事項】');
      constitution.knownIssues.forEach(issue => {
        sections.push(`- ${issue.description}（回避策: ${issue.workaround}）`);
      });
    }

    return sections.join('\n');
  }

  private formatTargetElements(elements?: SelectedElement[]): string {
    if (!elements || elements.length === 0) {
      return '未指定（依頼内容に基づきAIが判断）';
    }
    if (elements.length === 1) {
      return `${elements[0].text}（${elements[0].lineNumber}行目）`;
    }
    return elements
      .map((e, i) => `${i + 1}. ${e.text}（${e.lineNumber}行目）`)
      .join('\n');
  }
}
```

#### 12.13.10 生成されるプロンプト例

**入力**:
- LLM: claude
- DiagramType: activity
- UserRequest: 「ユーザー認証フローにエラー処理を追加して」

**生成されるプロンプト**:

```
【コード修正実行】

■ ユーザーの依頼
「ユーザー認証フローにエラー処理を追加して」

■ 修正対象
:認証処理;（12行目）

■ 適用コード
if (認証成功?) then (yes)
  :ダッシュボードへ;
else (no)
  :エラー表示;
  stop
endif

■ PlantUML生成ルール
【禁止事項】
- 複数の @startuml〜@enduml ブロックを出力しない
- 「以下のコードを...」等の前置きを出力しない
- コード後の解説や補足を出力しない
- if/elseif/else 内でスイムレーン（|lane|）遷移しない
- fork/join 内でスイムレーン遷移しない
- partition内でのif文使用を避ける

【必須ルール】
- 必ず @startuml で開始し @enduml で終了する
- コードブロックは1つのみ出力する
- endif後に1行アクションを入れてからスイムレーン遷移する
- シンプルなフロー構造を優先する

【既知の制限事項】
- if内スイムレーン遷移でレンダリングエラー（回避策: if全体を1スイムレーン内に収める）
- endif直後のスイムレーン遷移でエラー（回避策: endif後に1行アクション）

■ 出力形式
修正後の完全なPlantUMLコード（@startuml〜@enduml）のみ。
説明文は不要です。
```

#### 12.13.11 プロンプトビルダーファクトリ

```typescript
// PromptBuilderFactory.ts

class PromptBuilderFactory {
  constructor(
    private resolver: IConstitutionResolver,
    private templateEngine: ITemplateEngine
  ) {}

  create(type: PromptContext['type']): IPromptBuilder {
    switch (type) {
      case 'apply':
        return new ApplyPromptBuilder(this.resolver, this.templateEngine);
      case 'error_fix':
        return new ErrorFixPromptBuilder(this.resolver, this.templateEngine);
      case 'generate':
        return new GeneratePromptBuilder(this.resolver, this.templateEngine);
      default:
        throw new Error(`Unknown prompt type: ${type}`);
    }
  }
}

// AIService.ts での使用例

class AIService {
  constructor(
    private promptBuilderFactory: PromptBuilderFactory,
    private llmClient: ILLMClient
  ) {}

  async applyCode(context: ApplyContext): Promise<string> {
    // 1. 適切なビルダーを取得
    const builder = this.promptBuilderFactory.create('apply');

    // 2. プロンプトを構築（憲法が自動的に反映される）
    const prompt = await builder.build({
      type: 'apply',
      llm: context.selectedLLM,
      diagramType: context.diagramType,
      userRequest: context.userRequest,
      targetElements: context.targetElements,
      appliedCode: context.appliedCode,
      currentCode: context.currentCode
    });

    // 3. LLMに送信
    return this.llmClient.send(prompt);
  }
}
```

#### 12.13.12 運用改善サイクル

```
┌─────────────────────────────────────────────────────────────────┐
│                    憲法改善サイクル                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ① エラー発生・品質問題検出                                     │
│     例: Claude + Activity でif内遷移エラー頻発                  │
│                                                                 │
│                    ▼                                            │
│                                                                 │
│  ② 原因分析                                                     │
│     ├─ LLM固有の問題？ → llm/claude.yaml を更新                │
│     ├─ 図表固有の問題？ → diagram/activity.yaml を更新         │
│     └─ 組み合わせ固有？ → combined/claude_activity.yaml を作成 │
│                                                                 │
│                    ▼                                            │
│                                                                 │
│  ③ 憲法ファイル更新                                             │
│     ・YAMLファイルにルール追加                                  │
│     ・version更新                                               │
│     ・known_issuesに問題を記録                                  │
│                                                                 │
│                    ▼                                            │
│                                                                 │
│  ④ 即時反映                                                     │
│     ・デプロイ不要                                              │
│     ・ファイル更新のみで次回リクエストから反映                  │
│                                                                 │
│                    ▼                                            │
│                                                                 │
│  ⑤ 効果検証                                                     │
│     ・同じ操作で再現しないことを確認                            │
│     ・他の機能への影響がないことを確認                          │
│                                                                 │
│                    ▼                                            │
│                                                                 │
│  ⑥ 知見の蓄積                                                   │
│     ・憲法ファイルが運用ナレッジベースとして機能                │
│     ・新規LLM・図表追加時の参考資料に                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 12.13.13 MVP vs v1.1 スコープ

| 項目 | MVP | v1.1 |
|------|:---:|:----:|
| **Layer 1: 基底憲法** | ✅ | ✅ |
| **Layer 2: LLM層**（Claude, GPT-4） | ✅ | ✅ |
| **Layer 3: 図表層**（sequence, class, activity） | ✅ | ✅ |
| 全LLM対応（Gemini, Llama, Mistral） | ❌ | ✅ |
| 全図表対応（6種類以上） | ❌ | ✅ |
| **Layer 4: Combined層** | ❌ | ✅ |
| **ファイルベースプロバイダー** | ✅ | ✅ |
| Supabaseプロバイダー（DB管理） | ❌ | ✅ |
| 管理UI（憲法編集画面） | ❌ | ✅ |
| A/Bテスト機能 | ❌ | ✅ |
| 効果測定ダッシュボード | ❌ | ✅ |

**MVP実装範囲**:
- 基底憲法 + Claude/GPT-4 + sequence/class/activity
- ファイルベースの憲法読み込み
- 階層的マージロジック
- プロンプトビルダー3種類（apply, error_fix, generate）

#### 12.13.14 決定事項サマリー

| カテゴリ | 項目 | 決定内容 |
|---------|------|---------|
| **アーキテクチャ** | 構造 | 4層階層構造（Base→LLM→Diagram→Combined） |
| **アーキテクチャ** | 継承 | 差分定義、マージで最終憲法を解決 |
| **アーキテクチャ** | 格納形式 | YAML（MVP）、Supabase（v1.1） |
| **プロンプト** | 構築方式 | ビルダーパターン + ファクトリ |
| **プロンプト** | 憲法反映 | 動的に挿入（ハードコード禁止） |
| **運用** | 更新方式 | YAMLファイル更新のみ（デプロイ不要） |
| **運用** | 知見蓄積 | known_issuesに既知問題を記録 |
| **スコープ** | MVP | base + 2 LLM + 3 diagram |
| **スコープ** | v1.1 | 全LLM + 全図表 + Combined + 管理UI |

---

*End of Document*
